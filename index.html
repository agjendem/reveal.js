<!doctype html>
<html lang="no" xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Monorepo med Git og Maven: hvordan læra gamle hunder nye triks</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sb1.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
        <style>
            .reveal section img { background:none; border:none; box-shadow:none; }

			.reveal .slides section .fragment.underline {
				opacity: 1;
				visibility: visible;
			}

			.reveal .slides section .fragment.visible.underline {
				text-decoration: underline;
				text-decoration-color: #c94096;
			}

			.reveal .slides section .fragment.current-underline {
				opacity: 1;
				visibility: visible;
			}

            @font-face {
                font-family: "gotiskt";
                src: url("img/deutschgothic.woff") format('woff');
                font-weight: bold;
            }

            .gotiskt {
                font-family: gotiskt,serif !important;
            }

            .monorepocitat {
                color: #4eafff;
                font-family: serif;
                font-weight: 600;
                width: 90% !important;
                box-shadow: none !important;
            }

            .monorepocitat:first-letter {
                font-size: 1.5em;
                font-family: gotiskt,serif;
                color: #002776;
            }
        </style>
	</head>

	<body>
		<div class="reveal">
			<div class="slides">
                <section data-background="img/old-dog.jpg" data-background-size="contain">
                    <h1 style="font-weight: 700; text-align: left; color: white;">Monorepo<br/> med Git<br /> og Maven</h1>
                    <div style="height: 80px"> </div>
                    <h4 style="text-align: left; font-style: italic; color: white;">- hvordan lære gamle hunder nye triks</h4>
                    <div style="height: 30px"> </div>
                    <hr style="margin: 8px 0"/>
                    <div style="width: 100%; height: 50px; display: inline-flex; justify-content: space-between; align-items: center">
                        <span style="width: 141px; display: inline-flex; align-items: center">
                            <img alt="QR-kode med lenke til repository" width=50 height=50 style="margin: 0 0;" src="img/repo-url-qr.svg" />
                        </span>
                        <small style="color: white;">Anders Gjendem, Jonas Nordstrand</small>
                        <img alt="SpareBank 1 logo" width="141" height="39" style="margin: 0 0; background-color: rgba(255, 255, 255, 0.3);" src="img/logo.svg" />
                    </div>
                    <aside class="notes">
                        <h6>A</h6>
                        <p>
                            Jeg heter Anders og dette er Jonas, og vi vil snakke litt om våre første <strong>erfaringer</strong> med å migrere til <strong>monorepo</strong> i SpareBank 1, basert på være eksisterende verktøy.
                        </p>

                        <hr />
                        Bildekilde: https://pixabay.com/photos/dog-great-dane-old-animal-pet-2514968/
                    </aside>
				</section>

                <section data-timing="300" data-background="img/felleskode-pr.png" data-background-size="contain">

                    <aside class="notes">
                        <h6>A & J</h6>
                        <!-- TODO: Introduser skjermbildet - hva ser vi? -->
                        <!-- TODO: Hva er en PR/code review, og bruk "kodeendring" evt? -->
                        <!-- J -->
                        <p>
                        Detta ær en kode-diff hæmtat från en commit i en app som ska få lov att førbli namnløs. 
                        Diffen innehåller i stort set bara bumpningar av
                        versionsnummer till felleskoden som appen trenger.
                        </p>


                        <p>
                        Har du någon gång fått uppdraget att køra en code review'a med en sådan hær diff? 
                        Någon..? Åh, Anders har tydligen fått nøjet.
                        </p>

                        <p>
                        Hur kændes det, Anders? Hur skaffade du dig egentligen øverblick øver vilka kodeændringar
                        i felleskoden som dessa, på ytan, så oskyldiga ændringar av versionnummer inførde?
                        </p>

                        <!-- A -->

                        <p>
                        Jag rensade kalendern...
                        </p>


                        <!-- J -->
                        <p>Jag kænner Anders som en extrem samvetsgrann utvecklare. Alla ær kanske inte lika samvetsgranna
                        eller har lika mycket tid. <br/>
                        Det ær svårt att klandra någon før det egentligen. Vi har
                        alltid mycket att gøra och finna fram till kodediffar i olika repo's baserat
                        på en diff som denna ær border-line infeasible i arbetsvardagen.
                        Att man kapitulerar och trots den lilla (eller stora) knuten i magen
                        væljer att Approve'a ær bara naturligt.<br/>

                        <strong>Måste det vara så hær?</strong> Kan man jobba felleskode på ett annat, smartare
                        sætt som leder till PR:s dær man faktiskt kan se vad det ær før något som ændras?

                        <hr/>
                        (5 min)
                        Utfordringer med klassisk modell for å håndtere felleskode:
                        Mange repository og artifaktpublisering (Arbeidsflyt, waste, branching modeller)

                    </aside>
                </section>


				<section>
					<ul>
						<li class="fragment">Felleskode</li>
						<li class="fragment">Møt monorepo</li>
						<li class="fragment">Fra multi- til monorepo</li>
						<li class="fragment">Utfordringer</li>
						<li class="fragment">Positive effekter</li>
					</ul>

					<aside class="notes">
						<h6>A</h6>
						<p>
                            <strong>Hovedpunktene</strong> vi tenkte å gå igjennom i dag ser slik ut.<br/>
							Vi snakker litt om <strong>problemet med felleskode</strong>,<br/>
                            Vi tar en liten intro til <strong>hva et monorepo er</strong> for noe,<br/>
                            før vi ser på hvordan vi har prøvd å ta det <strong>i bruk</strong> i SpareBank1.<br/>
                            Til slutt så ser vi litt på hvilke <strong>utfordringer</strong> vi har møtt, og hvilke <strong>muligheter og effekter</strong> det har gitt oss.
						</p>
					</aside>
				</section>

                <section>
					<section data-timing="150" data-background="img/minefield.jpg" data-background-size="contain">

                        <aside class="notes">
                            <h6>J</h6>
							<p>
							Varje gång vi skriver kode som vi delar mellan appar så tar vi på oss <strong>risk</strong>. 
							Dær och då ær førdelarna med felleskode uppenbara medan riskerna ær mer diffusa:<br/> 
							man <strong>sparar tid</strong> på att inte behøva uppfinna hjulet igen och, inte minst,
							man ær sæker på att hjulet blir <strong>implementert likt</strong> på tværs av appar.
							</p>

							<p>
							Nej, risken blir først påtaglig længre fram. Till exempel nær man måste laga en liiiten fix i felleskoden och upptæcker att man
                            ligger lite bakpå och måste vælja mellan att fork'a eller ta in ændringar från de 23 versionerna man ligger
							bak før att få ut sin lilla fix. Delar man felleskode inte bara mellan sin egna appar utan æven mellan olika teams appar
							har man bevegt långt ut i ett minfælt av kopplingar och øverlæmningar som kan riskera førlama en hel organisation.
							</p>

                            <!--
                            <p>
							En del delar kode primært med Copy-Paste-metoden vilket ær en sæker form før kodedelning men dær
							man måsta acceptera hjulen efter tag kommer vara rætt olikt implementerade i apparna.
                            </p>
                            <p>
							Ett annat potentiellt felleskode-fritt alternativ ær kanske en fancy service-mesh / microservice-arkitektur, dær
							varje fellesfunktion ær sin egen tjeneste, men &ndash; till och med Google har felleskode.
							</p>

							<p>
							Vi i SpareBank 1 har (ænnu) inte microservices før all fellesfunktionalitet. Vi tillæmpar heller inte copy-paste 
							kodedelning. Vi ær en del av det norska bankvæsendet med allt som føljer av det vad gæller omdømmesrisisko,
							compliance-krav etc.  och vi ønskar att alla
							apparna i nettbanken till exempel ska ha en helt likt brukauktorisasjonslogik. Vi brukar aktivt felleskode
							før att våra 20 team ska vara i stånd att leverera appar dær vi kan vara komfortable med att central funktionalitet 
							ær konsistent och korrekt implementerat.
							</p>
                            -->
                            <p>
                            Vi i SpareBank 1 ær en del av det norska bankvæsendet med allt som føljer av det vad gæller omdømmesrisisko och krav på compliance.
                            Vi jobbar aktivt med felleskode før att våra 20-talet team ska vara i stånd att leverera nettbank-appar dær vi kan vara komfortable med att central funktionalitet 
                            ær konsistent och korrekt implementerat.
                            </p>
							<p>
							Før att bættre kunna navigera det minfælt som felleskode i en stor organisation faktiskt ær
							så har vi tagit valet att gå før monorepo.
							</p>
							<!--
                            <p>Har du inte felleskode så trenger du knappast monorepo!<br/>
                            Men Har du felleskode så kommer du vilja du ha monorepo efter att ha fått med dig
                            denna talk'en!</p>
							-->
							<hr />
							Bild av <a href="https://pixabay.com/sv/users/dimitrisvetsikas1969-1857980/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1592312">Dimitris Vetsikas</a> från <a href="https://pixabay.com/sv/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1592312">Pixabay</a>
                        </aside>
                    </section>

                    <section data-background="img/app-deps1.svg" data-background-size="contain">
                        <aside class="notes">
                            <h6>A</h6>
                            For å vise hvordan man gjerne <strong>jobber med felleskode i dag i et multirepo</strong> så har vi her et eksempel<br/>
                            <strong>To applikasjoner, og to felleskodemoduler</strong>.
                            Applikasjon 1 avhenger av <strong>både lib1 og lib2</strong><br/>
                            mens Applikasjon 2 avhenger <strong>bare av lib2</strong><br/>
                            <strong>Alle disse har sine egne repository</strong>.<br/>
                        </aside>
                    </section>

                    <section data-background="img/app-deps2.svg" data-background-size="contain">
                        <aside class="notes">
                            <h6>A</h6>
                            Det vi i praksis gjør når vi jobber med <strong>felleskode</strong> i multireposammenheng er at vi <strong>ikke avhenger direkte på koden</strong> til våre avhengigheter.<br/>
                            I stedet avhenger vi på <strong>bygde, versjonerte artifakter</strong> av koden.<br/>
                            Disse artifaktene lagres i kjent stil som <strong>separat fra kildekoden</strong> - typisk i Nexus.<br/>
                        </aside>
                    </section>

                    <section data-background="img/app-deps3.svg" data-background-size="contain">

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Ett eksempel:<br/>
                                Hvis man ønsker å <strong>lage en feature i applikasjon 1</strong> som innebærer at
                                <strong>felleskode i lib2 også må endres</strong>, så må det gjøres i <strong>to separate pull-request</strong> prosesser.
                            </p>
                        </aside>
                    </section>

                    <section data-background="img/app-deps4.svg" data-background-size="contain">

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                <i>Første trinn</i> er da en <strong>PR i lib2-repoet der diffen ikke viser hvordan felleskodeendringene treffer app1</strong>.
                            </p>
                        </aside>
                    </section>

                    <section data-background="img/app-deps5.svg" data-background-size="contain">

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                <i>Andre trinn</i> er når <strong>felleskoden er merget</strong>, og artefaktene bygd og deployet, så kan man gå <strong>videre med App1-repoet</strong> og
                                lage en ny PR hvor man <strong>bumper felleskodeversjonen til lib2</strong>, integrerer App1s kode med den nye versjonen og oppdaterer evt. noen tester.<br/>
                                Denne PRen er <strong>mulig å deploye til et testmiljø</strong>, men det som derimot ikke er mulig - eller ihvertfall ikke praktiskt - er å <strong>få en oversikt over kodeendringene i felleskoden</strong> som taes i bruk ved bumpingen.
                            </p>
                            <p>
                                Hvis vedkommende som har gjort pull requesten har vært flink så <strong>legger han opp begge samtidig, med samme reviewers og en midlertidig versjon</strong>, det hjelper _litt_.<br/>
                            </p>
                        </aside>
                    </section>

                    <section data-background="img/app-deps6.svg" data-background-size="contain">

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Men, fremdeles så har antakelig <strong>ingen tenkt på App2</strong> som også har en avhengighet av lib2, så den kan fint være brukket når den oppgraderes på et senere tidspunkt..
                            </p>
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                            Om det ær någon som gått på den talken och ær i tvil om vad som ær løsningen på alla multirepoproblem så kan jag upplysa om det:
                            så klart ær ett skickeligt monolitiskt kællkode-repository.
                            </p>
                            <p>
                            Vi har nu tænkt att gå mer i djupet kring vad som utmærker ett sådan repo.
                            </p>
                        </aside>

                    </section>
					<section data-background="img/bud.png" data-background-size="contain">
                        <br/>
                        <h1 class="gotiskt" style="font-size: 2.0em;">De Fem Monorepo-bud</h1>
                        <h4 class="gotiskt fragment" style="margin-top: 430px;color: #4eafff;">etter <span style="color: #c94096">Google</span> sitt evangelium</h4>
                        <aside class="notes">
                            <h6>J</h6>
							<p>
								Om det ær någon som gått på den talken och ær i tvil om vad som ær løsningen på alla multirepoproblem så kan jag upplysa om det:
                                så klart ær ett skickeligt monolitiskt kællkode-repository.
							</p>
							<p>
								Vi har nu tænkt att gå mer i djupet kring vad som utmærker ett sådan repo. Vi kommer utgå från en tæmligen
                                rigid regelsamling med <strong>fem olika påbud</strong> om vad som ska till før att man ska få lov før att få kalla sig monorepo.
                                Principerna ær givna till oss från det som ær høgsta møjliga ort i alla monoreposammanhang - <strong>Google</strong>.
							</p>
							<hr />
                            <p>
                                (7 min)
                                Vi ønsker oss enkelheten til ett repo, men fordelene fra å ha mange:
                                Møt monorepo: Egenskaper (Cross cutting refactoring, søkbarhet, versjonering), og hvem
                                passer det for?
                            </p>
							<small>Kilde:
								<a href="https://people.engr.ncsu.edu/ermurph3/papers/seip18.pdf">
									Advantages and Disadvantages of a Monolithic Repository - A case study at Google
								</a>
							</small>
                        </aside>
                    </section>

                    <section>
						<h1 class="gotiskt" style="font-size: 4.0em;">1.<!-- Centralization--></h1>

                        <blockquote class="monorepocitat">
                            The codebase is contained in a single repo encompassing multiple projects.
                        </blockquote>

                        <aside class="notes">
                            <h6>A</h6>
                            <strong>"Sentralisering: Kodebasen er samlet i ett repository som inneholder flere prosjekter"</strong><br/>
                            Dette er jo det punktet som åpenbart <strong>skiller en mono- og en multirepoorganisasjon</strong>.<br/>
                            I stedet for å modularisere ulike applikasjoner og deres fellesbibliotek i mange forskjellige repository<br/>
                            så <strong>samler man alt og bruker filstrukturen</strong> for å holde de adskilt og organisert.<br/>
                            Om det er <strong>felleskode, backendkode, frontendkode, mobilappkode, Java, Python, JavaScript - alt samles.</strong><br/>

                            Nå begynner jo det vi beskriver her å <strong>ligne mistenkelig på den gode gamle monolitten</strong> vår.<br/>
                            Den <strong>store forskjellen</strong> er at vi <strong>leverer selvstendige applikasjoner</strong>.<br/>
                        </aside>
                    </section>

                    <section>
						<h1 class="gotiskt" style="font-size: 4.0em;">2.<!-- Synchronization --></h1>

                        <blockquote class="monorepocitat">
                            The development process is trunkbased; engineers commit to the head of the repo.
                        </blockquote>

                        <aside class="notes">
                            <h6>J</h6>
                            <!-- <strong>"Synkronisering: Utviklingsprosessen er trunkbasert. Utviklerne committer til trunk i repositoriet"</strong><br/> -->

							<p>
                            Vi prøvar væl redan idag att <strong>unngå langtlevende brancher</strong>? I ett monorepo blir det viktigare æn någonsin eftersom
							det ær massiv churn på master-branchen.
							Featurebrancher merges ned til trunk eller master så raskt som mulig.<br/>
                            Det som ligger på trunk skal i størst mulig grad <strong>gjenspeile</strong> det som er i <strong>produksjon</strong>.<br/>
							<!--
                            Monorepo innebærer en radikalt <strong>annerledes</strong> måte å jobbe med felleskode på enn multirepo, og det gir både <strong>fordeler og ulemper</strong>.<br/>
							-->
							</p>
                        </aside>
                    </section>

                    <section>
                        <h1 class="gotiskt" style="font-size: 4.0em;">3.<!-- Visibility --></h1>

                        <blockquote class="monorepocitat">
                            Code is viewable and searchable by all engineers in the organization.
                        </blockquote>

                        <aside class="notes">
                            <h6>A</h6>
                            <strong>"Synlighet: Koden er synlig og søkbar for alle utviklerne i organisasjonen"</strong><br/>
                            Her ligger en av de store <strong>gevinstene</strong> for oss.<br/>
                            Med mindre du sjekker ut alle 1-200 repoene så er verktøyene vi har i dag helt <strong>ubrukelig til å søke</strong> etter kode.<br/>
                            Om du er så heldig å finne noe, så aner du ikke om den versjonen du ser er den som <strong>faktisk er i bruk</strong>, da må du grave i versjonsnummer og matche det med revisjonsnummer.<br/>
                        </aside>
                    </section>

                    <section>
						<h1 class="gotiskt" style="font-size: 4.0em;">4. <!-- Completenes--></h1>

                        <blockquote class="monorepocitat">
                            Any project in the repo can be built only from dependencies also checked into the repo.
                            Dependencies are <span class="fragment underline">unversioned</span>; projects must use whatever version of their dependency is at
                            the repo head.
                        </blockquote>

                        <aside class="notes">
                            <h6>J</h6>
                            <!-- <strong>"Kompletthet: Ethvert prosjekt i repoet kan bli bygd bare fra avhengighetene som er sjekket inn i repoet. Avhengigheter er uversjonerte, prosjektene må bruke den versjonen som ligger på HEAD"</strong><br/> -->
							<p>
							Detta ær nog det bud som vi syndar mest mot. Før i praktiken så innebær budet att monorepo't ditt
							inte bara ska innehålla allt av egen felleskode utan faktiskt æven den kode som kommer från tredjeparter.
							</p>
							<p>
							<strong>Kællkoden</strong> till det som du idag så praktiskt drar ner i jar-format från Maven-central ska alltså checkas in i
							monorepo't och byggas dærifrån. Det blir rætt så resurskrævande att hålla denna koden uppdaterad med up-stream och vi har
							føreløpigt valt at istællet checka in en så kallad BOM-fil som pinnar vilka versioner Maven brukar av tredjeparts-jar:erna på
							tværs av vårt monorepo.
							</p>
                            <p>
							Om man ær riktig storkarl i monorepo-sammanhang tar man detta ænnu ett steg længre och checkar in hela <strong>byggmiljøn</strong>
							i repo't: JDK:er, kompilatorer, etc. Frågan ær bara om man ska nøja sig med JDK-binærerna eller om man ska satsa på att æven bygga sjælva JDK'en
							från source...
							</p>
							<p>
                            En annan aspekt av ett monorepo ær avhængigheterna <strong>inte ær versionerade</strong>.
                            I princip så avhenger du alltid på <strong>siste versjon av alt</strong>.
                            Det er alltså <strong>inte længre møjligt att utsætta</strong> å ta inn felleskode gjennom å avhenge på en eldre versjoner som som 
                            man kan gjøre i ett multirepo-Mavenuppsætt.<br/>
                            </p>
                            <p>
							I et monorepo gjøres faktiskt <strong>all versjonering med versjonshåndteringssystemet</strong>.
							Hvilken <strong>versjon</strong> av felleskoden som en applikation bruker <strong>avgörs</strong> ene og alene av
                            <strong>Git-revisjonen</strong> - inte några versjonsnummer i pom.xml-filer.<br/>
							Hver git-revisjon anger en konsistent <strong>øgonblickbild</strong> av alle avhengigheter mellan appar og felleskode.<br/>
							</p>
                        </aside>
                    </section>

                    <section>
                        <h1 class="gotiskt" style="font-size: 4.0em;">5.<!-- Standardization --></h1>

                        <blockquote class="monorepocitat">
                            A shared set of tooling governs how engineers interact with the code, including building,
                            testing, browsing, and reviewing code.
                        </blockquote>

                        <aside class="notes">
                            <h6>A</h6>
                            <strong>"Standardisering: Felles verktøy bestemmer hvordan utviklerne interakterer med koden, inkludert bygging, testing, lesing og vurdering av koden"</strong><br/>
                            Monorepo har i praksis vært <strong>forbeholdt de store aktørene</strong> fordi tooling koster.<br/>
                            De nødvendige <strong>verktøyene</strong> for å bruke monorepo på store prosjekter begynner nå å bli tilgjengelig.<br/>
                            Google har open sourcet deler av sitt byggeverktøy <strong>Bazel</strong>.<br/>
                            Microsoft har gjort tilgjengelig sitt <strong>VFS for Git</strong> som gjør det mulig å versjonskontrollere <strong>_store_ mengder kode</strong> i ett vanlig gitrepo.<br/>
                            I tillegg har vi fått standarder som <strong>CODEOWNERS</strong> for å håndtere <strong>eierskap til kode og reviewers</strong> på pull requests.<br/>
                        </aside>
                    </section>
                </section>

                <section>
                    <section data-background="img/monolitt-multirepo-monorepo-blank1.svg" data-background-size="contain">
						<aside class="notes">
                            <h6>J - Monolitt</h6>
                            <p>
                            SpareBank 1:s nett- og mobilbank var en stor och tætt kopplad <strong>enterprise Java-monolit</strong>. <!-- som ble versjonskontrollert i ClearCase. -->
                            <strong>Produktionssættningar</strong> var våldsamma saker med månge involverte, långe testperioder og frysperioder.
                            Nattreleaser, høy risiko, lang ledetid og ikke minst nedetid var ikke til å komme utenom.
                            I praksis var det <strong>ikke mulig å skalere opp</strong> utviklerorganisasjonen til det nivået vi ønsket oss, siden vi uansett
                            ikke hadde greid å fått det ut dørren. Något måste gøras.
                            </p>
						</aside>
					</section>

                    <section data-background="img/monolitt-multirepo-monorepo-blank2.svg" data-background-size="contain">
						<aside class="notes">
                            <h6>A - Multirepo</h6>
                            <p>
                                For cirka seks år siden begynte vi å <strong>bryte opp monolitten</strong> i mindre applikasjoner som kunne <strong>deployes frittstående</strong> fra hverandre.<br/>
                                Utviklingen av applikasjonene skjer i dag av <strong>dedikerte team, som jobber i egne repository</strong>.<br/>
                                Denne reisen har vi allerede vært å presentert her et par ganger tidligere, senest i fjor.
							</p>
							<p>
                                Mye av koden i den gamle <strong>monolitten ble videreført som felleskode</strong> som applikasjonene avhenger av.<br/>
                                Felleskoden ligger i <strong>egne repository</strong>, og bygges i kjent stil til Nexus.<br/>
                                For å håndtere et <strong>økende antall team og applikasjoner</strong> har vi utviklet <strong>omfattende intern tooling</strong> for å holde<br/>
                                applikasjonene mest mulig <strong>oppdatert</strong> med den siste versjonen av <strong>felleskoden</strong>.<br/>
                             </p>
						</aside>
					</section>

                    <section data-background="img/monolitt-multirepo-monorepo-blank3.svg" data-background-size="contain">
						<aside class="notes">
                            <h6>J - Monorepo</h6>
                            <p>
                                Vi driver nå å går i <strong>retning av tilstandsløse, skyklare applikasjoner</strong> som helt kutter båndet til den gamle monolitten.<br/>
                                Vi har <strong>fremdeles felleskode</strong>.<br/>
                                MEN, vi har valgt å <strong>prøve ut monorepo</strong> på den nye generasjonen applikasjoner.
                                OG vi prøver å første omgang å <strong>benytte de verktøyene vi allerede kan</strong> godt, som Git, Maven og Jenkins.
                            </p>
						</aside>
					</section>

                    <section>
                        <pre><code class="stretch console" data-trim data-noescape>
$ tree
.
├── apps
│   ├── app1
│   │   ├── pom.xml
│   │   └── src
│   ├── app2
│   │   ├── pom.xml
│   │   └── src
│   └── pom.xml
├── libs
│   ├── lib1
│   │   ├── pom.xml
│   │   └── src
│   ├── lib2
│   │   ├── pom.xml
│   │   └── src
│   └── pom.xml
├── pom.xml
├── README.md
                        </code></pre>

                        <aside class="notes">
                            <h6>A</h6>
                            <strong>Monorepoet vårt i dag er et Maven multimodul-bygg med hovedsaklig to toppnivåmoduler, og ser ut noenlunde som dette:</strong>
                            <ul>
                                <li>apps - våre applikasjoner</li>
                                <li>libs - felleskoden</li>
                            </ul>
                        </aside>
                    </section>

                    <section data-background="img/maven-moduler.svg" data-background-size="contain">
                        <aside class="notes">
                            <h6>J</h6>

                            <p>
                            Vi brukar det i den hær førsamlingen kanske inte <strong>helt okænda</strong>, javabaserade byggverktyget, Maven før att bygga monorepot.
                            I Maven definierar man enheter att bygga, moduler, med pom-filer som kan referera submoduler som gærna placeras på en lægre nivå
                            i filsystemet. I praktiken brukar modulstrukturen i ett mavenprojekt avspegla filsystemshierakin rætt tætt.
                            </p>

                            <p>
                            Maven ær i grunden ett <strong>rekursivt byggsystem</strong>, som bygger från en rot katalog/module och nedåt i modultrædet.
                            Andra byggsystem som f.eks. Bazel ær <strong>grafbaserade</strong> vilket kan vara mer flexibelt och naturligt i ett monorepo.
                            Bazel ær en open sourcing'n av byggsystemet som brukas før att bygga kan værldens størst monorepo, Google's, och,
                            och ær ett i monoreposammanhang rætt intressant produkt.
                            </p>

                            <p>
                            Vi har ænnu inte tagit steget att uppgradera till Bazel, det ær också en fråga om vilka verktyg som programmerna kænner och har kompetens på.
                            Bazel ær mer æn materia før en egen talk och vi kommer inte gå in i detalj på Bazel i vår talk idag. <br/>
                            Dock utspelar sig alla maven-expempel som vi kommer gå igenom idag i ett 
                            <a href="https://github.com/SpareBank1/monorepo-sample">exempel-monorepo som vi har lagt ut på github</a>
                            som ær uppsatt att bygga med både Maven och Bazel men idag kommer vi bara berøra Maven.
                            </p>
                        </aside>
                    </section>

                    <section data-background="img/maven-moduler-deps.svg" data-background-size="contain">
                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                                Med maven kan man ha avhængigheter mellan moduler på tværs av filtrædstruktur
                            </p>
                        </aside>
                    </section>

                    <section>
                        <pre><code class="console" data-trim data-noescape>
$ mvn clean install<span class="fragment">
[INFO] Scanning for projects...
[INFO] ----------------------------------------------------
[INFO] Reactor Build Order:
[INFO]
[INFO] root                                           [pom]
[INFO] libs                                           [pom]
[INFO] lib2                                           [jar]
[INFO] lib1                                           [jar]
[INFO] apps                                           [pom]
[INFO] app1                                           [jar]
[INFO] app2                                           [jar]
[INFO]
                        </span></code></pre>

                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                                Det ær avhængigheterna mellan modulerna som bestæmmer i vilken ordning modulerna byggs.
                            </p>
                        </aside>
                    </section>

                    <section>
                        <pre><code class="console" data-trim data-noescape>
<span class="fragment underline">apps/app1</span> $ mvn clean install<span class="fragment">
[INFO] Scanning for projects...
[INFO] ----------------------------------------------------
[INFO] Reactor Build Order:
[INFO]
[INFO] app1                                           [jar]
[INFO]
                        </span></code></pre>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Her bygger Maven rekursivt fra apps/app1, og bygger ingen avhengigheter som appen
                                måtte ha som ligger utenfor den arbeidskatalogen vi står i i filsystemet.
                            </p>
                        </aside>
                    </section>

                    <section>
                        <pre><code class="console" data-trim data-noescape>
<span class="fragment underline">apps/app1</span> $ mvn <mark class="fragment">-f ../..</mark> <mark class="fragment">-pl :app1</mark> <mark class="fragment">-am</mark> clean install<span class="fragment">
[INFO] Scanning for projects...
[INFO] ----------------------------------------------------
[INFO] Reactor Build Order:
[INFO]
[INFO] root                                           [pom]
[INFO] libs                                           [pom]
[INFO] lib2                                           [jar]
[INFO] lib1                                           [jar]
[INFO] apps                                           [pom]
[INFO] app1                                           [jar]
[INFO]
                        </span></code></pre>

						<aside class="notes">
                            <h6>A</h6>
                            <p>
                                Hvis vi holder oss i samme arbeidskatalog og ønsker å få bygd også felleskoden som app1 bruker,
                                så må vi til med noen ekstra opsjoner:
                            </p>
                            <ul>
                                <li>-f: --file (angi filsti til rot-pom, kreves for at Maven skal ta utgangspunktet i rotkatalogen og finne alle moduler i prosjektet)</li>
                                <li>-pl: --projects (prosjektlisten, hvilke moduler eller applikasjoner skal Maven bygge)</li>
                                <li>-am: --also-make (instruerer Maven til å også bygge alle avhengighetene til modulene angitt i prosjektlisten)</li>
                            </ul>
						</aside>
                    </section>

                    <section>
                        <h2>filsti == groupId</h2>
                        <p><span class="fragment fade-in"><code>libs/lib1</code> &rArr;</span> <code class="fragment fade-in">no.monorepo.libs.lib1</code></p>
                        <p><span class="fragment fade-in"><code>apps/app2</code> &rArr;</span> <code class="fragment fade-in">no.monorepo.apps.app2</code></p>

                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                                Maven's namespace før moduler ær baserat på groupId-begreppet. I ett monorepo ær name space
                                ivaratatt av filtrædet, och groupId-begreppet i Maven ær i princip smør på flæsk.
                                Nær man brukar Maven før monorepo kan man vurdera att sætta groupId identisk till filsti.
                            </p>
                        </aside>
                    </section>

					<section>
                        <h2>Versjonering i Maven</h2>

                        <pre><code class="xml" data-trim data-noescape>
&lt;project&gt;
  &lt;groupId&gt;no.monorepo.libs&lt;/groupId&gt;
  &lt;artifactId&gt;lib1&lt;/artifactId&gt;
  &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
                        </code></pre>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Maven bruker <strong>SNAPSHOT</strong>-versjoner som tolkes som den "siste" deployede binærartifakten.<br/>
                                Dette passer dårlig med monorepo-tankegangen om at <strong>versjonskontrollsystemet skal stå for versjonering</strong>, og at det er <strong>ingen avhengigheter til binære artifakter</strong>.<br/>
                                Det hadde vært mer naturlig <strong>om Maven brukte aktuell Git-revisjon</strong> som versjon, men det fungerer ikke så bra når versjonsnummeret er <strong>lagret i pom.xml</strong>-filene.<br/>
                            </p>
                        </aside>
                    </section>

                    <section>
                        <h3>CI-vennlig versjonering</h3>
                        <pre><code class="xml" data-trim data-noescape>
&lt;project&gt;
  &lt;groupId&gt;no.monorepo.libs&lt;/groupId&gt;
  &lt;artifactId&gt;lib1&lt;/artifactId&gt;
  &lt;version&gt;<span class="fragment underline">${revision}</span>&lt;/version&gt;

  &lt;properties&gt;
    &lt;revision&gt;1.0-SNAPSHOT&lt;/revision&gt;
  &lt;/properties&gt;
                        </code></pre>

                        <br/>

						<pre class="fragment fade-up"><code class="console" data-trim data-noescape>
$ mvn -Drevision=$(git rev-parse HEAD) clean install
                        </code></pre>

						<aside class="notes">
                            <h6>J</h6>
							<p>
                            Maven har på senare tid fått stød før så kallade  <a href="https://maven.apache.org/maven-ci-friendly.html">ci-friendly</a> versioner.
                            Det innebær att man kan parametriera version med en property som man kan sætta från kommandolinjen. 
                            </p>
                            <p> 
                            Vi sætter enkelt property'n till aktuellt git commit vid bygging på byggserver.
							</p>
						</aside>
                    </section>

					<section>
						<h2>Flate pom-filer</h2>
						<aside class="notes">
                            <h6>A</h6>
							<p>
                                For å unngå at pom-filer med <strong>$revision</strong>-innslag som ikke er "konkretisert" blir installert,
                                kan man bruke Maven sin <a href="https://www.mojohaus.org/flatten-maven-plugin/"><strong>flatten-pluginen</strong></a>.<br/>
                                Denna <strong>resolver revisjonsnummer, fjerner bygg- og utviklingsspesifikke detaljer som test-avhengigheter</strong> og produserer en pom-fil som er <strong>tilrettelagt for publisering til tredjepart</strong>, og som kan brukes i fremtidige bygg uten problemer.
                                I eksemplet vi har lagt ut på Github kan dere se hvordan det fungerer i praksis.
                            </p>
						</aside>
					</section>

					<section>
                        <pre><code class="xml" data-trim data-noescape>
&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;no.monorepo.libs.lib1&lt;/groupId&gt;
    &lt;artifactId&gt;lib1&lt;/artifactId&gt;
    &lt;version&gt;${project.version}&lt;/version&gt;
  &lt;/dependency&gt;
                        </code></pre>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                I monorepoet er <strong>alle Maven-artifakter på samme versjon, dvs. Git HEAD</strong>.
                                Da er det naturlig å brukte project.version-propertyen for å referere til avhengigheter inne i monorepoet.
                            </p>
                        </aside>
					</section>

					<section>
						<h2>CODEOWNERS</h2>
						<pre class="fragment fade-up"><code data-trim data-noescape>
# Default owner
/ @nordstrand

# Code owner for the applications
/apps/app1/   @nordstrand
/apps/app2/   @agjendem
                        </code></pre>

						<img src="img/codereview-in-github.png" alt="eksempel på hvordan github viser codereviewers via codeowners-fil" class="fragment fade-in"/>

						<aside class="notes">
                            <h6>A</h6>
							<p>
                                En av de store fordelene med <strong>multirepo</strong> er at det er <strong>lett for teamene å være autonome</strong> og på egenhånd sette opp og administrere rutiner rundt tilgang til kildekode og "peer reviews".<br/>
                                I et <strong>monorepo</strong> som deles på tvers av mange team må dette <strong>sentraliseres</strong> på tvers av teamene i større utstrekning.<br/>
                                Et vanlig oppsett er å åpne for <strong>lesetilgang</strong> til alle, men kreve <strong>godkjent "pull request"</strong> for å få lov til å merge ned på trunk.<br/>
                            </p>

							<p>
                                En <strong>CODEOWNERS-fil</strong> i monorepoet definerer hvilke team/teammedlemmer som eier koden under ulike filstier.<br/>
                                Dette kan brukes til å f.eks. automatisk legga inn eiere som reviewers på pull requester som treffer deres respektive kode.<br/>
                            </p>

							<p>
                                CODEOWNERS-filformatet er <a href="https://help.github.com/articles/about-codeowners/"><strong>standardisert</strong></a>
                                og støttes av Github hvis man er betalende bruker, samt Gitlab og Bitbucket Server med plugin.
							</p>

							<p>
                                I dette eksempelet fra Github blir jeg automatisk lagt til som reviewer med et spesielt nøkkelhullikon på alle pull requests som treffer min app - app1.
                            </p>
						</aside>
					</section>

                    <section>
                        <h2>Jenkins(file)</h2>
                        <pre class="fragment fade-up"><code class="console" data-trim data-noescape>
$ git diff --name-only origin/master...HEAD
apps/app2/src/main/java/no/monorepo/app2/App2.java
apps/app2/README.md
                        </code></pre>

                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                                I ett monorepo vill man ha møjligt att køra olika byggpipelines beroende på vilka filer som har ændrat sig.
                                Vi har valt att lægga upp egna Jenkinsfile's før varje app i monorepot så att teamen som æger de olika apparna har møjlighet
                                att f.eks. sætta upp sina testmiljøer som man ønskar.
                            </p>
                            <p>
                                Detta har i utgångspunkt inte Jenkins stød før, och det finns inte heller læmpliga plugins att tillgå.
                                Vi har løst detta med en root Jenkinsfile som hjælp av git diff-kommando finner fram till exakt vilka filer som har ændrats
                                i en PR jæmført mot master.
                            </p>
                        </aside>
                    </section>

                    <section>
                        <h2>Jenkins(file)</h2>
                        <img alt="Jenkinsfile diagram - appspesifikk Jenkinsfile eller build-the-world?" src="img/jenkinsfile-diagram.svg" />

                        <aside class="notes">
                            <h6>J</h6>
                            Vår root-jenkinsfile finner vilka Jenkinsfile(s) som ær berørda av diffen och delegerar till den mest specifika.

                            Gør man ændring på felleskode så berørs i regel flera Jenkinsfile och vi lastar då en default pipeline som bygger hela
                            monorepo't.
                        </aside>
                    </section>

                    <section>
                        <h2>partial-build-plugin</h2>
                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                                Att bygg <strong>hela</strong> monorepo't från maven clean blir en længre och længre process ju større repo't blir.
                                Andra byggsystem (Bazel) har stød før inkrementell bygging, dær bara den kod som har ændrats och dess avhængigheter blir byggt. Vi tar tagit i bruk
                                <a href="https://github.com/lesfurets/partial-build-plugin">partial-build-plugin</a> en plugin som hackar sig in i maven
                                och prøvar att bara bygga moduler som har en diff mot trunk, lite likt upplægget kring val av Jenkinsfile.
                                Dessværre ær pluginen insomnad på Github, men den har fungerat fint før oss så långt.
                            </p>
                        </aside>
                    </section>

                    <section>
                        <h2>Sparse checkouts</h2>
                        <pre class="fragment fade-up"><code class="plaintext" data-trim data-noescape>
.git/info/sparse-checkout
/*
!/apps/*/*
/apps/app1/*
                        </code></pre>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Hvis <strong>kodebasen</strong> blir så stor at det er <strong>upraktisk å sjekke ut</strong> alt, eller man faktisk bare <strong>jobber med en konkret applikasjon</strong> uten behov for å endre felleskode så finnes det utveier.<br/>
                                Med <strong>"sparse checkouts"</strong> kan man instruere Git til å sjekke ut en delmengde av arbeidstreet.<br/>
                                I <strong>eksempelet</strong> her så sier vi at vi i utgangspunktet vil ha alle filer, men ikke alle applikasjonene, før vi igjen sier at vi vil ha app1 som er den vi jobber på.<br/>
                                Resultatet blir da at vi får det vi trenger av felleskode samt app1.<br/>
                                Ved å bruke sparse checkouts på denne måten får man i praksis en <strong>utvikleropplevelse som er temmelig lik den man har med multirepo</strong>, foruten at felleskoden er tilgjengelig.<br/>
                                Hvis man endrer på felleskoden bør man jo helst ha all koden tilgjengelig.<br/>
                                Eventuelt så vil forhåpentligvis byggserveren og tester plukke opp eventuelle feil og mangler.<br/>
                            </p>
                        </aside>
                    </section>

                    <section>
                        <img alt="Manglende app2 i filstrukturen ved Sparse checkouts og standard maven modules-liste" style="height: 152px" src="img/modules-missing-sparse.png" />

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Nå skurrer kanskje dette litt for mange av dere, <strong>Maven vil jo ikke like at halve kodebasen er borte</strong>?<br/>
                                I utgangspunktet <strong>støtter ikke Maven sparse checkouts</strong>, siden modul-lista i apps f.eks. vil referere til applikasjoner vi ikke har koden til.<br/>
                                Maven ønsker jo å bygge en komplett modell av alle modulene, basert på pom.xml før den gjør noe som helst, og vil selvfølgelig protestere.<br/>
                            </p>
                        </aside>
                    </section>

                    <section>
                        <pre><code class="xml" data-trim data-noescape>
&lt;profile&gt;
  &lt;id&gt;app2&lt;/id&gt;

  &lt;activation&gt;
    &lt;file&gt;
      &lt;exists&gt;app2/pom.xml&lt;/exists&gt;
    &lt;/file&gt;
  &lt;/activation&gt;

  &lt;modules&gt;
    &lt;module&gt;app2&lt;/module&gt;
  &lt;/modules&gt;
&lt;/profile&gt;
                        </code></pre>

                        <aside class="notes">
                            <h6>A</h6>
							<p>
                                Ved å bruke <strong>Maven-profiler</strong> litt kreativt kan vi komme oss rundt dette, og bygge opp modules-lista basert på profiler.<br/>
                                Disse profilene igjen <strong>trigges av om pom.xml-fila til appen faktisk finnes</strong>.<br/>
                                På den måten får vi en <strong>dynamisk liste av applikasjonsmoduler</strong> slik Maven ser det, og det fungerer "greit nok".<br/>
							</p>
                        </aside>
                    </section>
				</section>

				<section>
                    <section data-background="img/thumb-down.png" data-background-size="contain">

						<aside class="notes">
                            <h6>J</h6>
                            <p>
                                Som det kanske framgått så har det inte varit <strong>helt problemfritt</strong> før oss att komma igång monorepo. En del
                                smærta kan kanske hærledes till att vi envist hållit fast vid ett vælkænt Java-baserad byggverktyg trots att det
                                finns attraktiva alternativ.
                            </p>
                            <p>
                                Men vi har också børjat få smake på en del av sura sidorna med monorepo som vi tror ær mer fundamentala och generiska.
                                Vi har också læst upp oss en del på de problem som blir påtagliga først vid en større skala æn den vi hunnit uppnå.
                            </p>
                            <hr />
                            Image by <a href="https://pixabay.com/users/OpenClipart-Vectors-30363/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=153290">OpenClipart-Vectors</a> from <a href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=153290">Pixabay</a>
							<p>
								(7 min)
								Hvilke nye utfordringer får vi nå?
								* Umodne verktøy (Maven vs Bazel, BitBucket / GitHub vs Gerrit)
								* Tvinges til mer kortlevde brancher
								* Skalering
							</p>
						</aside>
					</section>

                    <section>
                        <h2>Stort repository?</h2>
                        <ul>
                            <li class="fragment fade-in">VFS for Git</li>
                            <li class="fragment fade-in">Sparse Checkouts</li>
                            <li class="fragment fade-in">Large File Storage</li>
                        </ul>

                        <aside class="notes">
                            <h6>A</h6>
                            Over tid <strong>vokser gjerne kodebasen</strong>. Per i dag så regner vi ikke med at <i>vi</i> møter på de største problemene - kanskje med unntak av prosjekter hvor vi versjonerer <strong>store maskinlæringsmodeller</strong> og andre binære datafiler.
                            Avhengig av hva som er årsaken, er det <strong>flere måter å angripe problemet</strong> på:<br/>
                            <ul>
                                <li>Vente og håpe verktøyene blir bedre av seg selv</li>
                                <li>Hvis det er metadata/historikk i .git/-katalogen kan kanskje virtuelle filsystem a'la Microsofts <strong>VFS for Git</strong> være løsningen. Foreløpig best støtte på Windows, men Mac støttes og Linux ser ut til å være under arbeid.</li>
                                <li>Hvis det er working-treet som er problemer er kanskje <strong>sparse checkouts</strong> som nevnt over en del av løsningen</li>
                                <li>også kan det kanskje være lurt å så på om <strong>Git Large File Storage</strong> kan være et alternativ for å unngå å ha store binærfiler som del av selve repositoriet. <strong>Arbeidsflyten i Git forblir uendret</strong> når de filene som skal lagres med LFS er definert, så det kan være et godt alternativ. I praksis så lagres det en fil med en peker til hvor fila kan finnes. Den lagres på en egen LFS-server knyttet til repositoriet ditt. Både Github og BitBucket støtter LFS.</li>
                            </ul>
                        </aside>
                    </section>

                    <section>
                        <canvas data-chart="line">
                            <!--
                            {
                             "data": {
                              "labels": ["Google","Microsoft Windows","Linuxkernel","Multirepo","Monorepo"],
                              "datasets": [
                               {
                                "data":[9000000, 3500000, 65000, 40000, 1500],
                                "label":"Antall filer","backgroundColor":"#002776"
                               }
                              ]
                             },
                             "options": {
                                "responsive": "true", "animation": {"duration": "9000", "easing": "easeInExpo"},
                                "scales": { "yAxes": [{ "display": false }] }
                              }
                            }
                            -->
                        </canvas>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Vi prøvde å finne noen tall på hva de store har stappet inn i sine monorepo-repository.<br/>
                                Som vi ser her, så er vi jo bare smågutter, så vi er <strong>ikke spesielt bekymret for skaleringen</strong> i så måte.<br/>
                                <strong>Nettbanken</strong> vår består av rundt 40.000 filer, kanskje.<br/>
                                Det er <strong>vanskelig å få oversikt</strong> siden det er oppdelt i så mange repository.<br/>
                                I monorepoet er det trivielt å få oversikten, og foreløpig er det veldig tidlig i migreringen.<br/>
                                Vi har per nå i overkant av <strong>20</strong> små, tilstandsløse applikasjoner der, fordelt på cirka <strong>1500 filer</strong>.<br/>
                            </p>

                            <hr />
                            <a href="https://git-lfs.github.com/">Git Large file storage</a><br/>
                            <a href="https://github.com/Microsoft/VFSForGit/issues/126">VFS for Git on Linux</a><br/>
                            <a href="https://github.com/github/libprojfs">VFS for Git on Linux</a><br/>
							<a href="https://devblogs.microsoft.com/devops/exploring-new-frontiers-for-git-push-performance/">Exploring new frontiers for Git push performance</a><br/>
                        </aside>
                    </section>

                    <section>
                        <h2>Lange byggtider</h2>
                        <!--
                        <ul>
                            <li>Ikke bygg alt alltid</li>
                            <li>Ikke bygg fra "clean" alltid <span class="fragment fade-in">(vurder alternativ til Maven)</span></li>
                            <li class="fragment fade-in">Bazel har støtte for <i>build cache</i> og <i>build workers</i></li>
                        </ul>
                        -->
                        <aside class="notes">
                            <h6>J</h6>
                            <p>
								Om stort repo ær det førsta problemet som slår en nær man tænker monorepo, så ær sækert långa byggtider
                                det andra.<br/>
								Ingen gillar att vænta på långsamma bygg. Och med mer kode i samma repo så måste væl byggtiderna gå upp?
                            </p>
							<p>
								Resonemanget ær i stor sett korrekt: att bygga mer kode tar i regel længre tid æn att bygga mindre kode.
                                Før att undgå før långa byggtider så handlar det om att bruka de verktygen som vi har alltid har tillgång
                                till nær vi ska prøva att få någonting på data'n att gå snabbare:
							</p>
                            <ul>
                                <li>bryta ner i mindre bitar och kør bitarna  <strong>parallellt</strong> - gærna på egna CPU cores</li>
                                <li>gøra <strong>mindre</strong>, typiskt genom smartare algoritmer eller bruk av caches</li>
                            </ul>
                            <p>
                                Maven har haft rudimentært stød før att bygga moduler parallellt sedan version 3. Caching av byggresultat,
                                eller <strong>inkrementell bygging</strong> ær svårt att få till med Maven dær man i regel alltid bygger
                                från en clean utgångspunkt. På båda punkterna ær Bazel rætt øverlægsen.
                            </p>
                        </aside>
                    </section>

					<section data-background="img/race.jpg" data-background-size="contain">
                        <h2 style="margin-top: -130px; background: rgba(255,255,255,0.6)">The race to merge</h2>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                I et monorepo ønsker man naturligvis at master-branchen <strong>alltid</strong> skal bygge grønt.<br/>
                                Da har du overordnet to måter å håndtere det på:<br/>
                            </p>
                            <p>
                                For å sikre dette kan man ikke tillate å merge pull requester som ikke er <strong>basert på siste versjon av master</strong>.<br/>
                                Altså <strong>må</strong> man <strong>rebase</strong> inn master i pull requesten før den kan merges.<br/>
                            </p>
                            <p>
                                Det store problemet med dette, er at etter at man har <strong>rebaset pull requesten</strong> sin, og alle testene har kjørt igjen,
                                så har noen andre rukket å få merget sin pull request før deg.. og da er det bare å starte på nytt.
                            </p>
                            <p>
                                <strong>Jo flere utviklere og applikasjoner vi ruller på, jo verre blir det</strong>.<br/>
                                Antakelig er løsningen på dette alternativet en eller annen form for <strong>automatisering</strong> hvor man markerer at "denne pull requesten ønsker jeg å merge",
                                også blir den <strong>lagt i kø</strong> og håndtert automatisk så lenge alle testene fremdeles kjører grønt.
                            </p>

                            <hr />
                            <a href="https://docs.microsoft.com/en-us/azure/devops/learn/git/race-to-push">The race to push</a><br/>
                            Bild av <a href="https://pixabay.com/sv/users/skeeze-272447/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=558089">skeeze</a>
                            från <a href="https://pixabay.com/sv/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=558089">Pixabay</a>
                        </aside>
                    </section>

					<section data-background="img/success-fail-rollback.png" data-background-size="contain">
                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                <strong>Den andre måten er å tolerere at det ikke alltid er tilfellet at den bygger grønt, akseptere rebase på serversiden, og automatisere tilbakerulling om noe feiler</strong>.<br/>
                                Vi har valgt å prøve å gå for den <strong>siste varianten</strong>, hvor vi har automatisert <strong>tilbakerulling</strong> av PR, og <strong>varsling</strong> til involverte hvis noe skjærer seg.<br/>
                                Vi tror at for oss, så er det mer effektivt å <strong>håndtere en slik feil som en vanlig produksjonsfeil</strong>, og gjøre oppfølgning og forbedringstiltak i etterkant av en slik hendelse
                            </p>
                        </aside>
                    </section>

                    <section>
                        <h2>Monolitt 2.0</h2>
                        <img class="fragment" src="img/archunit.png" alt="ArchUnit screenshot from Github, introducing the library" />

                        <aside class="notes">
                            <h6>J</h6>
                            <p>
								I ett monorepo ær det lættare æn någonsin att dela kode och inføra nya avhængigheter på kors och tværs -
								nu slipper man faktiskt krullet med att finna
								fram till vilken version man ønskar. Baksidan av myntet ær det ær rætt lætt att vara odisciplinerad och lægga inte avhængigheter på lite væl
								mycket felleskode, och, om man inte pasar sig, så har vi kanske snart en ny tætt kopplad monolit.
                            </p>
                            <p>
								Detta måsta vi bara undgå. Vi har ænnu inte kommit till den punkten dær detta kan bli ett problem, men med større skala så ær vi nyfikna
								på att titta på kodekvalitetsverktyg som <a href="https://www.archunit.org/">Archunit</a>. Archunit låter dig skriva junit-enhetstester
								som på klassnivå verfieriar att man f.eks. inte har avhængigheter mellan appar i ett monorepo.
                            </p>
                        </aside>
                    </section>

                    <section>
                        <h2>Overmodent</h2>

							<span class="fragment">
                                <img src="img/maven.png" style="height: 100px;" alt="Maven logo" />
							</span>
							<span class="fragment">
                                <img src="img/jenkins.png" style="height: 150px;" alt="Jenkins logo" />
							</span>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Maven begynner jo å dra på årene, førsta release av <a href="https://maven.apache.org/docs/history.html"><strong>Maven ble sluppet 30. mars 2002</strong></a>.<br/>
                                I 2005 kom Maven 2.0, i 2010 kom Maven 3.0, og på de årene har mange andre verktøy kommet og godt, og mye har skjedd.<br/>
                            </p>
                            <p>
                                Mange av <strong>de tingene som knirker mest</strong> nå i Maven-monoreposammenheng har vi allerede vært inne på:<br/>
                            </p>
                            <ul>
                                <li>Ikke polyglot - <strong>Javasentrisk</strong></li>
                                <li><strong>Sparse checkout må hackes til</strong> siden Mavens repomodell bygges opp av pom.xml filer - ikke hva som finnes på disk</li>
                                <li>Maven trenger <strong>eksplisitt referanse til roten</strong> av repositoryet. Bazel finner den fint selv.</li>
                                <li><strong>Mangler inkrementella bygg</strong> - man bygger i hovedsak alltid fra clean tilstand</li>
                                <li>Maven brukar <strong>groupId og versjons-begrep</strong> for moduler som i et monorepo <strong>heller utledes</strong> fra filkatalogstrukturen respektive Git</li>
                            </ul>
                            <p>
                                Jenkins er en annen gammel traver som først så dagens lys under navnet Hudson tilbake i 2008.<br/>
                                Mange år og mange plugins senere, så mangler Jenkins fremdeles støtte for monorepo i form av selektiv bygging basert på diff.<br/>
                            </p>
                        </aside>
                    </section>

                    <section>
                        <h2>Umodent</h2>
                        <span class="fragment">
    						<img style="width: 40%" alt="Bazel logo" src="img/bazel.png" />
                        </span>
                        <span class="fragment">
    						<img style="width: 60%" alt="Git VFS logo" src="img/gitvfs.png" />
                        </span>

                        <aside class="notes">
                            <h6>J</h6>
                            <p>
								Monorepo'n har længe varit førbehållet de stora drakarna. Tooling som t.ex. versionskontroll, code review och byggsystem har
								utvecklats innanfør murarna till bedrifter som Google och Facebook.
								De allmænt tillgængliga verktygen ær anpassade multirepo har i varierande grad varit møjliga att skalera upp till monorepo-skala. 
								Mycket av det vi snackat om idag ær faktiskt just olika sider med att bruka multirepoverktyg i ett monorepo. <br />
								Allt detta håller på och ændra sig: framførallt på versionskontroll och byggsystemsidan har det de sista åren kommit ut nya 
                                opensourceverktyg som ændrar allt. 
                            </p>
							<p>
								Samtidigt ær det inte att sticka under stolen att dessa verktygen fortfarande ær omogna.<br/>
								<strong>Google's Bazel</strong>, ær fortsatt i beta - faktiskt med en 1.0 release planerad i dagarna - och
								ekosystemet ær mycket svagare æn Maven's nær det gæller IDE-støtte, plugins och så vidare. <br/>
								<strong>Microsoft VFS løsning før git</strong> stødjer fortsatt officiellt inte Linux.
							</p>
							<!--
							<p>
								CI - mangler ferdige løsninger for å bygge deler av monorepo
							</p>
							<p>
								Bitbucket/Github mangler ordentlig støtte for store monorepo - CODEOWNERS er et plaster
							</p>
							-->
                        </aside>
                    </section>

                    <section>
                        <h2>... men</h2>
                        <span>
                            <img src="/img/men.svg" alt="Illustrasjon med snakkebobler med motforestillinger til monorepo" />
                        </span>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Det er <strong>fordeler og ulemper</strong> med alt. Vi har nå prøvd <strong>multirepo i ganske mange år</strong>, og
                                håndterer forsåvidt det "greit nok" - men det er ikke gøy med 100+ repository heller.
                            </p>
                            <p>
                                Nå hadde vi <strong>muligheten til å se på om monorepo</strong> kunne løse noen av våre utfordringer,
                                og vi har tid og lyst til å se om dette kan være <strong>noe for oss i større eller mindre skala</strong>.
                            </p>
                            <p>
                                Mange av <strong>ankepunktene</strong> mot monorepo gjelder <strong>store organisasjoner</strong> med enorme mengder kode.
                                Vi har mange utviklere, vi har mye kode, på mange språk, men <strong>vi er på ingen måte enorme</strong>.
                                Det finnes kanskje en <strong>middelvei</strong> her?
                            </p>
                            <p>
                                Vi tror at ved å <strong>begynne i det små</strong> og ta stegene gradvis så bør vi greie å komme opp med en god løsning på utfordringene,
                                og kunne løse de større over tid når de nærmer seg et problem. Foreløpig er vel kanskje
                                <strong>hybrid-repo</strong> et bedre navn på det vi gjør, og vi tenker at det er helt greit å ta skrittene
                                gradvis. Det er <strong>ikke gitt at det er fornuftig for oss å blande alt</strong> i en stor haug, men
                                å <strong>samle det som hører sammen</strong> virker forlokkende, ihvertfall.
                            </p>
                            <p>
                                Hvis dette ikke er en flopp, så har det en <strong>tendens til å dukke opp løsninger</strong> på utfordringene
                                i form av nye verktøy og bedre tredjepartsstøtte, se bare på Bazel.
                            </p>
                            <p>
                                Vi ser <strong>ingen grunn til å ikke utforske mulighetene</strong>, og i verste fall så er det ingen big deal å splitte
                                opp til flere repository igjen, den biten kan vi. Også er det jo også slik at vi har
                                brukt, og <strong>bruker den dag i dag mye tid på tooling</strong> for multirepo også.
                            </p>
                            <p>
                                Igjen; <strong>alt gjør vondt</strong>, spørsmålet er bare hvor du foretrekker å ha smerten.
                            </p>
                        </aside>
                    </section>
				</section>

				<section>
                    <section data-background="img/thumb-up.png" data-background-size="contain">

                        <aside class="notes">
                            <h6>J</h6>
                            <p>
							Jobbing i ett monorepo ær på många sætt rætt radikalt annorlunda æn hur vi jobbar med multirepo idag.
							</p>
							<p>
                            Att vi børjade med monorepo var inte bara før att monorepo ær <strong>the next shiny thing</strong> vi trodde också att
							det faktiskt skulle ha en del utslagsgivande positiva effekter. Vi har nu tillræckligt med praktiska erfarenhet før att kunna dela lite kring
							vilka effekter vi har upplevt.
                            </p>
							<hr />
							<p>
                            (7 min)
                            Med monorepo; hva blir mer viktig, og hva blir mindre viktig?
                            Hvordan påvirker monorepo samarbeidet i organisasjonen?
                            Positive bi-effekter av monorepo.
                            </p>
                        </aside>
                    </section>

					<section>
                        <h2>Versjonering</h2>
                        <ul>
                            <li style="font-family: monospace" class="fragment fade-out">$ mvn version:set</li>
                            <li style="font-family: monospace" class="fragment fade-out">$ mvn release:begin</li>
                            <li style="font-family: monospace" class="fragment fade-out">&lt;version&gt;</li>
                            <li style="font-family: monospace" class="fragment fade-out">-SNAPSHOT</li>
                            <li style="font-family: monospace" class="fragment fade-out">&lt;dependencyManagement&gt;</li>
                            <li style="font-family: monospace" class="fragment fade-out">Bill-of-Materials (BOM)</li>
                            <li style="font-family: monospace" class="fragment fade-out">dependency-version-convergence</li>
                            <li style="font-family: monospace" class="fragment fade-out">NPM semantisk versjonering</li>
                            <li style="font-family: monospace" class="fragment fade-out">NPM pinning</li>
                            <li style="font-family: monospace" class="fragment fade-out">NPM lock-filer</li>
                        </ul>
						<aside class="notes">
							<h6>A</h6>
							<p>
                                <strong>Tidligere så versjonerte vi i både Git og Maven</strong>.<br/>
                                I monorepo versjonerer vi bare i Git<br/>

                                Konseptuelt så er det mye <strong>lettere å forholde seg til KUN en Git revisjon</strong>,<br/>
                                enn å måtte forholde seg til maven sin version plugin, release-plugin, &lt;version&gt; SNAPSHOTs, dependencyManagement, BOM'er, dependency-version-convergence, og NPMs SemVer, pinning, lock-filer og alt annet som er oppfunnet for å gjøre avhengigheter til å leve med.<br/>
                                Det vil si, så lenge vi beholder <strong>tredjepartsbibliotek eksternt</strong>, så må vi beholde noe av dette - men det <strong>blir ihvertfall mindre og mer oversiktlig</strong><br/>
							</p>
							<p>
                                I tillegg krever det <strong>mindre behov før komplisert tooling</strong> for å holde apper oppdatert med nye versjoner av felleskode.
							</p>
						</aside>
					</section>

                    <section data-background="#0071cd">
                        <h2 style="color: white">Jobbing med felleskode</h2>
                        <p  style="color: white" class="ffe-lead-paragraph">Hvis du ikke har et monorepo, integrerer du ikke kontinuerlig - i beste fall hyppig!</p>

                        <aside class="notes">
                            <h6>J</h6>
                            Att jobba med felleskode i ett monorepo ær helt annorlunda, och bættre, æn i multirepo:
                            <ul>
                                <li>Ønskar du se alla konsumenter av en API-funktion? Det ær bara ett IDE-kommando bort.</li>
                                <li>Nyfiken på om en felleskodeændring knæcker en konsument? Det ær enkelt (i alla fall i Bazel)
                                    att køra alla konsumenteras tester. Och ær det något som knæcker så ær det møjligt att fixa
                                    det i samma PR som felleskodeændringen!</li>
                                <li>Man kan laga <i>atomiska refaktoreringar</i> som tar hela værlden från ett konsistent tillstånd
                                    till ett annat utan någon mellanliggande period dær saker ær knæckta. En sida av detta ær att integrationstiden går
                                    ner: man har inte længre den falska viloputen att man kan førdrøja integrationen som att ligga kvar på gamla versioner -
                                    sækerhetsuppdateringar och kritiska fixar i felleskoden kom direkt ut i alla appar.</li>
                                <li>Bump PR:s utan meningsfulla diffar blir ett gammalt ont minne</li>
                            </ul>

							<p>
								Sammantaget sænker monorepo trøskeln, som annars kan vara rætt høg, før att folk vågar refaktorer/bidra till felleskode.
							</p>
							<!--
							<p>
                               Tidigare kunde man ændra felleskode utan att att ta ansvara før att integrera
                               ændringen i konsumenterna. Med monorepo blir man mer ansvarligt før konsumenterna,
                               det blir också praktiskt møjligt att gøra det.
                            </p>
							-->
                        </aside>
                    </section>

                    <section data-background="#0071cd">
                        <img alt="Sitat fra utvikler med mange års erfaring" src="img/sitat.svg"/>

                        <aside class="notes">
                            <h6>J</h6>
                        </aside>
                    </section>

                    <section data-background="img/2nd-order-effects.jpg" data-background-size="contain">
                        <h2 style="color:white">Second order effects</h2>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <h3 style="color:white">i SpareBank 1 Utvikling</h3>
                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Historisk sett har nettbanken vår vært oppdelt i <strong>to forskjellige markeder</strong>; privat og bedrift.<br/>
                                Disse har stort sett vært vedlikeholdt av <strong>ulike team</strong>, og vi har noen applikasjoner som er <strong>kloner</strong> av hverandre,<br/>
                                eller hvor samme funksjonalitet er implementert for begge markeder med mindre variasjoner<br/>
                            </p>
                            <p>
                                Vi antar at monorepoet her vil gi oss <strong>bedre gjennomsiktighet og samarbeidsmuligheter</strong> på tvers av team,<br/>
                                og vi har allerede tilfeller hvor vi samme app nå opptrer i begge markeder, med litt forskjellige konfigurasjon<br/>
                            </p>
                            <hr />
                            Biljardbild: https://pixabay.com/photos/billiards-pool-play-game-sport-1967938/
                        </aside>
                    </section>

                    <section data-background="img/survey.jpg" data-background-size="contain">
                        <h2>Googles erfaringer</h2>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
						<p class="ffe-small-text" style="color:black; background-color: rgba(255, 255, 255, 0.2);">Advantages and Disadvantages of a Monolithic Repository:
                        A case study at Google<br/>
                        Ciera Jaspan, Matthew Jorde, Andrea Knight, Caitlin Sadowski, Edward K. Smith, Collin Winter-Google;
                        Emerson Murphy-Hill NC State University
                        </p>
                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                            Någon som har <strong>en del</strong> monorepoerfarenhet ær Google.
							Google har ett gigantisk monorepo med faktiskt <strong>decennier</strong> med historik. Repo't anvænds av øver 20.000 utvecklare.
                            Google ær intresserade av vad deras erfarenheter och gick i 2018 vetenskapligt till verks. Det genomførde
							en større enkætundersøkelse samtidigt som det samlades in loggdata om hur repo't anvændes.
                            </p>

                            <p>
                            Det visade sig att utvecklarna <strong>starkt prefererade</strong> ett jobba i monorepo't nær detta sattes
                            upp mot tidigare erfarenhet av jobb i en multirepo-miljø. (så det var kanske inte helt bortkastat att gå på den hær talken - trots allt)
							Det kan naturligtvis ifrågasættas i vilken grad det resultatet berodde på den inneboende styrkan i monorepotankegången och
                            i vilken grad resultatet kan vara påverkat av kvalitèn på Googles utvecklingsverktyg (versionshantering,
                            code review, code browsing, etc.) versus mot dær man hade jobbat med multirepo tidigare.
                            </p>

                            <p>
                            En kanske lite ovæntad finding var att den aspekt av monorepo't som utvecklarna satte mest pris på <strong>inte</strong>
                            var enkel versionering, atomiska refaktoreringar eller något annat av det vi næmnt tidigare.<br/>
                            Nej, det var tillgængligheten och søkbarheten av kællkoden før att f.eks. raskt finna relevanta kodeexempler som kom ut på topp.
                            </p>

                            <p>
                            Undersøkelse blev till ett <a href="https://people.engr.ncsu.edu/ermurph3/papers/seip18.pdf">intressant paper</a> som varmt rekommenderas.
                            </p>
                            <hr/>
                            Bilde: https://pixabay.com/photos/survey-opinion-research-voting-fill-1594962/
                        </aside>
                    </section>
                </section>

                <section>
                    <section>
                        <!-- Blank slide -->

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                <strong>Facebook</strong> populariserte komponentbasert <strong>frontendutvikling</strong> og virtuell DOM med <strong>React</strong><br/>
                                <strong>Google</strong> gjorde storskala <strong>containerorkestrering</strong> main-stream med <strong>Borg/Kubernetes</strong><br/>
                                På samme måte så mistenker vi at med de store aktørene som <strong>foregangsfigurer</strong> så vil monorepo etterhvert også bli mye vanligere enn hva det er i dag.<br/>
                                Tiden vil antakelig vise hvem som kan ta <strong>æren</strong> for det, men per nå så ligger nok<br/>
                                <strong>Google</strong> med sitt ambisiøse byggsystem <strong>Bazel</strong><br/>
                                og <strong>Microsoft</strong> med sitt bidrag på virtuelle <strong>filsystem</strong> for Git best ann.<br/>
                            </p>
                        </aside>
                    </section>

                    <section data-background="img/success.jpg" data-background-size="contain">
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <h2 style="background: rgba(255, 255, 255, 0.4)">Du får det til med Maven, Jenkins og Git!</h2>
                        <h3 class="fragment fade-in" style="background: rgba(255, 255, 255, 0.4)">(men på sikt kommer Bazel)</h3>
                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                <strong>Så, da blir vår erfaring så langt at, du får det til med Maven, Jenkins og Git</strong><br/>
                                <strong>.. men på sikt kommer nok Bazel</strong>
                            </p>
                            <hr />
                            Bild av <a href="https://pixabay.com/sv/users/StartupStockPhotos-690514/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=593313">StartupStockPhotos</a> från <a href="https://pixabay.com/sv/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=593313">Pixabay</a>
                        </aside>
                    </section>

                    <section>
                        <div style="width: 70%; display: inline-flex; justify-content: center; align-items: center; margin: 50px">
                            <img alt="QR-kode til https://github.com/SpareBank1/monorepo-sample" src="img/avslutning.svg" />
                        </div>

                        <aside class="notes">
                            <h6>En av oss:</h6>
                            <p>
                                Hvis noen vil se nærmere på oppsettet så har vi laget et <strong>eksempel-repository</strong> som ligger på Github.<br/>
                                <strong>Hvis vi har tid: Spørsmål fra salen?</strong><br/>
                                Vi kommer til å rusle ned til <strong>SpareBank1 sin stand</strong> etterpå og stå der en times tid. Kom gjerne å snakk med oss der!<br/>
                                <strong>Takk for oss!</strong>
                            </p>
                        </aside>
                    </section>
                </section>
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                history: true,
                controls: false,
                progress: false,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true },
                    { src: 'plugin/chart/Chart.min.js' },
                    { src: 'plugin/chart/csv2chart.js' }				]
			});

            Reveal.configure({
                pdfMaxPagesPerSlide: 1
            });
        </script>
	</body>
</html>
