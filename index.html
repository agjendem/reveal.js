<!doctype html>
<html lang="no" xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Monorepo med Git og Maven: hvordan læra gamle hunder nye triks</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sb1.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
        <style>
            .reveal section img { background:none; border:none; box-shadow:none; }

            .versionconcept {
                border-radius: 25px;
                background: rgba(0,0,0,0.2);
                border: 2px dotted;
                font-family: monospace;
                text-transform: none;
                text-decoration: line-through;
                text-decoration-color: #E60000;
                display: inline;
                padding-left: 15px;
                padding-right: 15px;
                margin: 5px 5px 5px 5px;
                white-space: nowrap;
            }

			.reveal .slides section .fragment.underline {
				opacity: 1;
				visibility: visible;
			}

			.reveal .slides section .fragment.visible.underline {
				text-decoration: underline;
				text-decoration-color: red;
			}

			.reveal .slides section .fragment.current-underline {
				opacity: 1;
				visibility: visible;
			}

            @font-face {
                font-family: "gotiskt";
                src: url("img/deutschgothic.woff") format('woff');
                font-weight: bold;
            }

            .gotiskt {
                font-family: gotiskt,serif !important;
                text-shadow: 2px 2px 2px #000000 !important;
            }

            .monorepocitat {
                color: #002776;
                font-family: serif;
                font-weight: 600;
                width: 90% !important;
                box-shadow: 0px 0px 6px rgba(0, 0, 0, 0.3) !important;
            }

            .monorepocitat:first-letter {
                font-size: 1.5em;
                font-family: gotiskt,serif
            }
        </style>
	</head>

	<body>
		<div class="reveal">
			<div class="slides">
                <section data-background="img/old-dog.jpg" data-background-size="contain">
                    <h1 style="text-align: left; text-shadow: 2px 2px 2px #C7C7C7">Monorepo<br/> med Git<br /> og Maven</h1>
                    <div style="height: 80px"> </div>
                    <h4 style="font-style: italic;color: white;text-shadow: 2px 2px 2px #181818;">- hvordan lære gamle hunder nye triks</h4>
                    <div style="height: 30px"> </div>
                    <hr style="margin: 8px 0"/>
                    <div style="width: 100%; height: 50px; display: inline-flex; justify-content: space-between; align-items: center">
                        <span style="width: 141px; display: inline-flex; align-items: center">
                            <img alt="QR-kode med lenke til repository" width=50 height=50 style="margin: 0 0;" src="img/repo-url-qr.png" />
                        </span>
                        <small style="color: white;text-shadow: 2px 2px 2px #181818;">Anders Gjendem, Jonas Nordstrand</small>
                        <img alt="SpareBank 1 logo" width="141" height="39" style="margin: 0 0; background-color: rgba(255, 255, 255, 0.3);" src="img/logo.svg" />
                    </div>
                    <aside class="notes">
                        <h6>A</h6>
                        <p>
                            Jeg heter Anders og dette er Jonas, og vi vil snakke litt om våre første <strong>erfaringer</strong> med å migrere til <strong>monorepo</strong> i SpareBank 1.
                        </p>

                        <hr />
                        Bildekilde: https://pixabay.com/photos/dog-great-dane-old-animal-pet-2514968/
                    </aside>
				</section>

                <section data-timing="300">
                    <img src="img/felleskode-pr.png" alt="Bumping av versjonsnummer på mange interne bibliotek"/>

                    <aside class="notes">
                        <h6>A & J</h6>

                        Har du någon gång får en PR att review'a med en sådan hær diff?
                        En diff som bara innehåller bumpning'ar av versionsnummer før
                        felleskodeavhængigheter som appen din trenger?<br/>

                        Instick: versionsnummer i diffen: varfør står det dev och inte master dær?<br/>

                        Hur kændes det? Tog du dig bryet att eftergå exakt vilka kodeændringar
                        dessa, på ytan, så oskyldiga ændringar av versionnummer inførde?<br/>

                        Inte det..? Det ær svårt att klandra någon før det egentligen. Vi har
                        alltid mycket att gøra och finna fram till kodediffar i olika repo's baserat
                        på en diff som denna ær border-line infeasible i arbetsvardagen.
                        Att man kapitulerar och trots den lilla (eller stora) knuten i magen
                        væljer att Approve'a ær bara naturligt.<br/>

                        Måste det vara så hær? Kan man jobba felleskode på ett annat, smartare
                        sætt som leder till PR:s dær man faktiskt kan se vad det ær før något som ændras?

                        <hr/>
                        (5 min)
                        Utfordringer med klassisk modell for å håndtere felleskode:
                        Mange repository og artifaktpublisering (Arbeidsflyt, waste, branching modeller)

                    </aside>
                </section>


				<section>
					<h1>Agenda</h1>
					<ul>
						<li>Dilemmaet med felleskode</li>
						<li>Møt Monorepo</li>
						<li>Vår reise fra multi- til monorepo</li>
						<li>Utfordringar</li>
						<li>Effekter</li>
					</ul>
					<aside class="notes">
						<h6>A</h6>
						<p>
                            <strong>Hovedpunktene</strong> vi tenkte å gå igjennom i dag ser slik ut.<br/>
							Vi snakker litt om <strong>problemet med felleskode</strong>,<br/>
                            Vi tar en liten intro til <strong>hva et monorepo er</strong> for noe,<br/>
                            før vi ser på hvordan vi har prøvd å ta det <strong>i bruk</strong> i vårt miljø.<br/>
                            Til slutt så ser vi litt på hvilke <strong>utfordringer</strong> vi har møtt, og hvilke <strong>muligheter og effekter</strong> det har gitt oss.
						</p>
					</aside>
				</section>

                <section>
					<section data-background="img/minefield.jpg" data-background-size="contain">
                        <h1>Felleskode</h1>
                        <h3>&ndash; a <i>mixed</i> blessing</h3>

                        <aside class="notes">
                            <h6>J</h6>
							<p>
							Varje gång vi skriver kode som vi delar mellan appar så tar vi på oss <strong>risk</strong>. 
							Risken ær aldrig særskilt påtaglig dær och då, nej då verkar det alltid vara en god idè:<br/> 
							man <strong>sparar tid</strong> på att inte behøva uppfinna hjulet igen och, inte minst,
							man ær sæker på att hjulet blir <strong>implementert likt</strong> på tværs av appar.
							</p>

							<p>
							Nej, risken blir først påtaglig længre fram. Till exempel nær man måste laga en liiiten fix i felleskoden och upptæcker att man
                            ligger lite bakpå och måste vælja mellan att fork'a eller ta in ændringar från de 23 versionerna man ligger
							bak før att få ut sin lilla fix. Delar man felleskode inte bara mellan sin egna appar utan æven mellan olika teams
							har man bevegt långt ut i minfælt av kopplingar och øverlæmningar som kan riskera førlama hela organisationen.
							</p>

                            <p>
							En del delar kode primært med Copy-Paste-metoden vilket ær en sæker form før kodedelning men dær
							man måsta acceptera hjulen efter tag kommer vara rætt olikt implementerade i apparna.</p>
                            <p>
							Ett annat potentiellt felleskode-fritt alternativ ær kanske en fancy service-mesh / microservice-arkitektur, dær
							varje fellesfunktion ær sin egen tjeneste, men &ndash; till och med Google har felleskode.
							</p>

							<p>
							Vi i SpareBank 1 har (ænnu) inte microservices før all fellesfunktionalitet. Vi tillæmpar inte copy-paste 
							kodedelning. Vi ær en del av det norska bankvæsendet med allt som føljer av det vad gæller omdømmesrisisko,
                            compliance-krav etc.  och ønskar att alla
							apparna i nettbanken till exempel ska ha en helt likt brukauktorisasjonslogik. Vi brukar aktivt felleskode
							før att våra 20 team ska vara i stånd att leverera appar dær vi kan vara komfortable med att central funktionalitet 
							ær konsistent och korrekt implementerat.
							</p>

							<p>
							Før att bættre kunna navigera det minfælt som felleskode i en stor utvecklingsorganisation faktiskt ær
							så har vi tagit valet att gå før monorepo.
							</p>
							<!--
                            <p>Har du inte felleskode så trenger du knappast monorepo!<br/>
                            Men Har du felleskode så kommer du vilja du ha monorepo efter att ha fått med dig
                            denna talk'en!</p>
							-->
							<hr />
							Bild av <a href="https://pixabay.com/sv/users/dimitrisvetsikas1969-1857980/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1592312">Dimitris Vetsikas</a> från <a href="https://pixabay.com/sv/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1592312">Pixabay</a>
                        </aside>
                    </section>

                    <section data-background="img/app-deps-utan-jar.png" data-background-size="contain">
                        <aside class="notes">
                            <h6>J</h6>
                            Før att visa hur hur man gærna jobbar idag  med felleskode i ett multirepo-sammanhang
                            har vi hær ett exempel.
                            Två applikation och två felleskodemoduler. App1 avhænger av lib1 och lib2, medan app2
                            bara avhænger av lib2. Alla i sina egna repos.

                            <hr/>
                            TODO: se om det blir bættre om man lægger apparna i en kolonn till vænster och
                            libs i en kolonn till høger

                            <hr/>
                            (5 min)
                            Utfordringer med klassisk modell for å håndtere felleskode:
                            Mange repository og artifaktpublisering (Arbeidsflyt, waste, branching modeller)

                        </aside>
                    </section>

                    <section data-background="img/app-deps-utan-jar-ci.png" data-background-size="contain">
                        <aside class="notes">
                            <h6>A</h6>
                            Det vi i praksis gjør når vi jobber med <strong>felleskode</strong> i multireposammenheng er at vi <strong>ikke avhenger på koden</strong> til våre avhengigheter <strong>direkte</strong>.<br/>
                            I stedet avhenger vi på <strong>bygde, versjonerte artifakter</strong> av koden.<br/>
                            Disse artifaktene lagres i kjent stil som <strong>binærfiler separat fra kildekoden</strong> - typisk i Nexus.<br/>
                        </aside>
                    </section>

                    <section data-background="img/app-deps-med-jar.png" data-background-size="contain">

                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                                Ett exempel: man ønskar laga en feature i app1 som innebær att felleskode i lib2
                                samtidigt måste ændras. Detta måste rent praktiskt ordnas som två PR-processer:
                            </p>
                            <ul>
                                <li>
                                    <i>først</i> en PR i lib2-repo't dær diffen inte visar hur felleskodeændringen
                                    træffar app1. PR:n ær också inte heller møjlig att testa på en høgre nivå.
                                </li>
                                <li>
                                    Nær denna førsta PR:n ær mergead, och artefakt ær byggd och deploy'ad, kan man få
                                    vidare med app1-repo't och laga en <i>andra</i> PR som bumpar versionnumret før
                                    lib2-artefakten, integrerar app1:s kode med den nya versionen av lib2 och uppdaterar
                                    høgnivåtesterna.<br/>
                                    Denna PR:n ær møjlig att deploy'a till en testmiljø - vad som dæremot inte ær
                                    møjligt, eller i allafall praktiskt, ær att få en øversikt øver kodeændringarna i
                                    felleskoden som tas i bruk vid versionsbump'en.
                                </li>
                            </ul>
                            <p>
                                Som en liten bonus: ingen har tænkt på app2 (som också avhænger på lib2) i detta sammahanget.
                                Denna appen kan nu vara knæckt (nær man bumpar lib2-versionen)!
                            </p>
                        </aside>
                    </section>
                </section>

                <section>
					<section data-background="img/bud.png" data-background-size="contain">
                        <h1 class="gotiskt" style="font-size: 2.0em;">Dem Femth Monorepo Bud</h1>
						<h4 class="gotiskt fragment">etter Google sitt evangelium</h4>
						<br/>
						<br/>
						<br/>
						<br/>
						<br/>
						<br/>

                        <aside class="notes">
                            <h6>J</h6>
							<p>
								Om det var någon som var i tvil om vad som ær løsningen på alla multirepoproblem så ær det så klart ett skickeligt monorepo.
							</p>
							<p>
								Vi har nu tænkt att gå mer i djupet kring vad som utmærker ett monolitisk kællkodsrepository. Vi kommer genomgå en tæmligen
								rigid regelsamling med fem olika påbud om vad som ska till før att man ska få lov før att få kalla sig monorepo.
								Principerna ær givna till oss från høgst møjliga ort - i.e. Google.
							</p>
							<hr />
                            <p>
                                (7 min)
                                Vi ønsker oss enkelheten til ett repo, men fordelene fra å ha mange:
                                Møt monorepo: Egenskaper (Cross cutting refactoring, søkbarhet, versjonering), og hvem
                                passer det for?
                            </p>
							<small>Kilde:
								<a href="https://people.engr.ncsu.edu/ermurph3/papers/seip18.pdf">
									Advantages and Disadvantages of a Monolithic Repository - A case study at Google
								</a>
							</small>
                        </aside>
                    </section>

                    <section>
						<h1 class="gotiskt" style="font-size: 4.0em;">1.<!-- Centralization--></h1>

                        <blockquote class="monorepocitat">
                            The codebase is contained in a single repo encompassing multiple projects
                        </blockquote>

                        <pre class="fragment">
                            <code data-trim data-noescape>
.
├── apps
│   ├── app1
│   │   ├── pom.xml
│   │   └── src
│   ├── app2
│   │   ├── pom.xml
│   │   └── src
│   └── pom.xml
├── libs
│   ├── lib1
│   │   ├── pom.xml
│   │   └── src
│   ├── lib2
│   │   ├── pom.xml
│   │   └── src
│   └── pom.xml
├── pom.xml
├── README.md
                            </code>
                        </pre>

                        <aside class="notes">
                            <h6>A</h6>
                            <strong>"Sentralisering: Kodebasen er samlet i ett repository som inneholder flere prosjekter"</strong><br/>
                            Dette er jo det punktet som åpenbart <strong>skiller en mono- og en multirepoorganisasjon</strong>.<br/>
                            I stedet for å modularisere ulike applikasjoner og deres fellesbibliotek i mange forskjellige repository<br/>
                            så <strong>samler man alt og bruker filstrukturen</strong> for å holde de adskilt og organisert.<br/>
                            Om det er <strong>felleskode, backendkode, frontendkode, mobilappkode, Java, Python, JavaScript - alt samles.</strong><br/>

                            Nå begynner jo det vi beskriver her å <strong>ligne mistenkelig på den gode gamle monolitten</strong> vår, som til og med hadde en håndfull avhengigheter bundlet.<br/>
                            Den store forskjellen er at vi <strong>leverer selvstendige applikasjoner</strong>.<br/>
                            <strong>Alle monolitter er monorepo, men alle monorepo er ikke monolitiske.</strong><br/>
                        </aside>
                    </section>

                    <section>
						<h1 class="gotiskt" style="font-size: 4.0em;">2.<!-- Synchronization --></h1>

                        <blockquote class="monorepocitat">
                            The development process is trunkbased; engineers commit to the head of the repo
                        </blockquote>

                        <aside class="notes">
                            <h6>J</h6>
                            <strong>"Synkronisering: Utviklingsprosessen er trunkbasert. Utviklerne committer til HEAD i repositoriet"</strong><br/>

                            - Når vi gjør endringer i felleskode i dag, så kan det ta månedsvis før alle har tatt inn
                            endringene, og det er vanskelig for den som endrer å gå rundt i alle prosjektene som bruker koden og rette
                            det selv.
                            Det gjør at når noen etterslepere endelig skal oppgradere, og har spørsmål, har man for lengst glemt hva det handlet om.
                            Med monorepo må man også endre alle konsumentene, hvis ikke bryter bygget.
                            <hr/>

                            I et monorepo gjøres <strong>all versjonering med versjonshåndteringssystemet</strong>. I vårt tilfelle er det Git.<br/>
                            Hvis man skal dra det helt ut, innebærer det at også <strong>tredjepartskode</strong> behandles på samme måte og <strong>sjekkes inn</strong>.<br/>
                            Vi har foreløpig valgt å ikke dra det så langt.<br/>
                            Hvilken <strong>versjon</strong> av vår egen felleskode som en applikasjon bruker <strong>avgjøres</strong> ene og alene av <strong>Git-revisjonen</strong> - ikke versjonsnummer i pom.xml-filer.<br/>
                            Hver git-revisjon angir et <strong>øyeblikksbilde</strong> av alle avhengigheter mellom appene og felleskode.<br/>
                            Det er <strong>ikke mulig å utsette</strong> å ta inn felleskoden gjennom å avhenge på en eldre versjon slik som man kan gjøre med Maven.<br/>
                            I prinsippet så avhenger du alltid på <strong>siste versjon av alt</strong>.<br/>
                            Man prøver å <strong>unngå langtlevende brancher</strong>. Featurebrancher merges ned til trunk eller master så raskt som mulig.<br/>
                            Det som ligger på trunk skal i størst mulig grad <strong>gjenspeile</strong> det som er i <strong>produksjon</strong>.<br/>
                            Monorepo innebærer en radikalt <strong>annerledes</strong> måte å jobbe med felleskode på enn multirepo, og det gir både <strong>fordeler og ulemper</strong>.<br/>
                        </aside>
                    </section>

                    <section>
                        <h1 class="gotiskt" style="font-size: 4.0em;">3.<!-- Visibility --></h1>

                        <blockquote class="monorepocitat">
                            Code is viewable and searchable by all engineers in the organization
                        </blockquote>

                        <pre class="fragment">
                            <code data-trim data-noescape>
$ git grep lib1 -- '**/pom.xml'
apps/app1/pom.xml:            &lt;groupId&gt;no.monorepo.libs.lib1&lt;/groupId&gt;
apps/app1/pom.xml:            &lt;artifactId&gt;lib1&lt;/artifactId&gt;
libs/lib1/pom.xml:    &lt;groupId&gt;no.monorepo.libs.lib1&lt;/groupId&gt;
libs/lib1/pom.xml:    &lt;artifactId&gt;lib1&lt;/artifactId&gt;
libs/pom.xml:        &lt;module&gt;lib1&lt;/module&gt;
                            </code>
                        </pre>

                        <aside class="notes">
                            <h6>A</h6>
                            <strong>"Synlighet: Koden er synlig og søkbar for alle utviklerne i organisasjonen"</strong><br/>
                            Her ligger en av de store <strong>gevinstene</strong> for oss.<br/>
                            Med mindre du sjekker ut alle 1-200 repoene så er verktøyene vi har i dag helt <strong>ubrukelig til å søke</strong> etter kode.<br/>
                            Om du er så heldig å finne noe, så aner du ikke om den versjonen du ser er den som <strong>faktisk er i bruk</strong>, da må du grave i versjonsnummer og matche det med revisjonsnummer.<br/>
                        </aside>
                    </section>

                    <section>
						<h1 class="gotiskt" style="font-size: 4.0em;">4. <!-- Completenes--></h1>

                        <blockquote class="monorepocitat">
                            Any project in the repo can be built only from dependencies also checked into the repo.
                            Dependencies are <span class="fragment underline">unversioned</span>; projects must use whatever version of their dependency is at
                            the repo head.
                        </blockquote>

                        <aside class="notes">
                            <h6>J</h6>
                            <strong>"Kompletthet: Ethvert prosjekt i repoet kan bli bygd bare fra avhengighetene som er sjekket inn i repoet. Avhengigheter er uversjonerte, prosjektene må bruke den versjonen som ligger på HEAD"</strong><br/>

                            - Denne er krevende å få til for en halvstor organisasjon.
                            Vi drar skillelinjen mellom tredjepartskode og vår felleskode.
                            De store kan ta kostnaden med å dra denne strikken enda lengre, og
                            versjonere _alt_ i eget repo, det er for ressurskrevende å følge
                            all tredjepartskode i detalj.
                            Vi har valgt å sjekke inn vår BOM som holder oversikt over- og
                            definerer hvilke tredjepartsbibliotek vi bruker.

                            Per definisjon skal man vel egentlig dra det så langt at også <strong>tredjepartskode og utviklingsverktøy</strong> som JDKer, kompilatorer osv også samles, og det finnes absolutt de som gjør det.<br/>
                            Så langt har definitivt ikke vi kommet, og jeg er vel skeptisk til om det vil være hensiktsmessig å dra det så langt for noen på vår størrelse med det første.<br/>
                            Heldigvis går det ann å ta ting <strong>trinnvis</strong> og gjøre vurderinger underveis på en slik reise.<br/>
                        </aside>
                    </section>

                    <section>
                        <h1 class="gotiskt" style="font-size: 4.0em;">5.<!-- Standardization --></h1>

                        <blockquote class="monorepocitat">
                            A shared set of tooling governs how engineers interact with the code, including building,
                            testing, browsing, and reviewing code.
                        </blockquote>

                        <aside class="notes">
                            <h6>A</h6>
                            <strong>"Standardisering: Felles verktøy bestemmer hvordan utviklerne interakterer med koden, inkludert bygging, testing, lesing og vurdering av koden"</strong><br/>
                            Monorepo har i praksis vært <strong>forbeholdt de store aktørene</strong> fordi tooling koster.<br/>
                            De nødvendige <strong>verktøyene</strong> for å bruke monorepo på store prosjekter begynner nå å bli tilgjengelig.<br/>
                            Google har open sourcet deler av sitt byggeverktøy <strong>Bazel</strong> som i disse dager blir sluppet i versjon 1.0.<br/>
                            Bazel er et <strong>graf-basert</strong> byggverktøy.<br/>
                            Google har også gjort tilgjengelig en plugin for <strong>IntelliJ</strong> slik at det er relativt lett å ta i bruk.<br/>
                            Microsoft har gjort tilgjengelig sitt <strong>VFS for Git</strong> som gjør det mulig å versjonskontrollere <strong>_store_ mengder kode</strong> i ett vanlig gitrepo.<br/>
                            I tillegg har vi fått standarder som <strong>CODEOWNERS</strong> for å håndtere <strong>eierskap til kode og reviewers</strong> på pull requests.<br/>
                        </aside>
                    </section>
                </section>

                <section>
					<section>
                        <h1>Vår reise</h1>

                        <ol>
                            <li class="fragment">Monolit</li>
                            <li class="fragment">Multirepo</li>
                            <li class="fragment">Monorepo</li>
                        </ol>

						<aside class="notes">
                            <h3>Monolit</h3>
                            <h6>A</h6>
                            <p>
                                SpareBank 1s nett- og mobilbank var en stor <strong>enterprise Java-monolitt</strong> som ble versjonskontrollert i ClearCase.
                                <strong>Produksjonssettingen</strong> var en voldsom greie med mange involverte, lange testperioder og frysperioder.
                                Nattreleaser, høy risiko, lang ledetid og ikke minst nedetid var ikke til å komme utenom.
                                I praksis var det <strong>ikke mulig å skalere opp</strong> utviklerorganisasjonen til det nivået vi ønsket oss, siden vi uansett
                                ikke hadde greid å fått det ut døra. Noe måtte gjøres.
                            </p>

                            <h3>Multirepo</h3>
                            <h6>J</h6>
                            <p>
                                Før cirka seks år sedan børjade vi bryta upp monoliten i mindre  applikationer som kunde
                                deploy'as fristånde från varandra. Utvecklingen av apparna sker idag
                                av dedikerade team som jobbar i egna repos. Mycket av koden i den gamla monoliten vidareførdes som felleskode
                                som apparna avhænger av. Felleskoden ligger i egna repos och byggs till binærer som uppbevaras i Nexus
                                på kænt java-manèr. Før att hantera ett stigande antal team (p.t ~20) som ansvarar før ett stændigt økande antal appar har vi
                                utvecklat omfattande intern tooling før att hålla apparna uppdaterade med senaste versioner felleskode. Denna resan har Anders&amp;co
                                redogjort om från denna scen vid två tillfællen (2015 och 2018).
                            </p>

                            <h3>Monorepo</h3>
                            <h6>A</h6>
                            <p>
                                Vi driver nå å går i <strong>retning av tilstandsløse, skyklare applikasjoner</strong> som helt kutter båndet til den gamle monolitten.<br/>
                                Vi har <strong>fremdeles felleskode</strong>.<br/>
                                MEN, vi har valgt å <strong>prøve ut monorepo</strong> på den nye generasjonen applikasjoner.
                                OG vi prøver å første omgang å <strong>benytte de verktøyene vi allerede kan</strong> godt, som Git, Maven og Jenkins.
                            </p>
						</aside>
					</section>

                    <section>
                        <pre>
                            <code data-trim data-noescape>
.
├── apps
│   ├── app1
│   │   ├── pom.xml
│   │   └── src
│   ├── app2
│   │   ├── pom.xml
│   │   └── src
│   └── pom.xml
├── libs
│   ├── lib1
│   │   ├── pom.xml
│   │   └── src
│   ├── lib2
│   │   ├── pom.xml
│   │   └── src
│   └── pom.xml
├── pom.xml
├── README.md
                            </code>
                        </pre>

                        <aside class="notes">
                            <h6>A</h6>
                            <strong>Monorepoet vårt i dag er et Maven multimodul-bygg med hovedsaklig to toppnivåmoduler, og ser ut noenlunde som dette:</strong>
                            <ul>
                                <li>apps - våre applikasjoner</li>
                                <li>libs - felleskoden</li>
                            </ul>
                        </aside>
                    </section>

                    <section>
                        <img src="img/maven-moduler.png" alt="oversikt over maven moduler i prosjektet" style="background:none; border:none; box-shadow:none; ">
                        <aside class="notes">
                            <h6>J</h6>

                            <p>
                                Maven ær i grunden ett rekursivt byggsystem, ikke ett graf-baserat som e.g. bazel. Bazel ær en open sourcing'n av byggsystemet som brukas
                                før att bygga Google's monorepo och, føga førvånande, ær det också ur många perspektivt mer læmpat før Monorepo æn vad Maven ær.
                            </p>

                            <p>
                                Vi har ænnu inte tagit steget att uppgradera till Bazel, det ær också en fråga om vilka verktyg som programmerarna kænner och har kompetens på.
                                Bazel ær mer æn materia før en egen talk och vi kommer inte gå in i detalj på Bazel i vår talk idag. Alla exempel vi visar idag utspelar
                                sig i ett <a href="https://github.com/SpareBank1/monorepo-sample">exempel-monorepo på github</a>.
                                Monorepot ær uppsatt att bygga med både Maven och Bazel men idag kommer vi bara berøra Maven.
                            </p>
                        </aside>
                    </section>

                    <section>
                        <img src="img/maven-moduler-deps.png" alt="oversikt over maven moduler i prosjektet med noen avhengigheter" style="background:none; border:none; box-shadow:none; ">
                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                                Med maven kan man ha avhængigheter på tværs av filtrædstruktur
                            </p>
                        </aside>
                    </section>

                    <section>
                        <pre>
                            <code data-trim data-noescape>
$ mvn clean install
[INFO] Scanning for projects...
[INFO] ----------------------------------------------------
[INFO] Reactor Build Order:
[INFO]
[INFO] root                                           [pom]
[INFO] libs                                           [pom]
[INFO] lib2                                           [jar]
[INFO] lib1                                           [jar]
[INFO] apps                                           [pom]
[INFO] app1                                           [jar]
[INFO] app2                                           [jar]
[INFO]
                            </code>
                        </pre>

                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                                Det ær avhængigheterna mellan modulerna som bestæmmer i vilken ordning modulerna byggs.
                            </p>
                        </aside>
                    </section>

                    <section>
                        <pre>
                            <code data-trim data-noescape>
$ apps/app1 $ mvn clean install
[INFO] Scanning for projects...
[INFO]
[INFO] --------------------------< no.monorepo:app1 >------
[INFO] Building app1 1.0.0-SNAPSHOT
[INFO] --------------------------------[ jar ]-------------

                            </code>
                        </pre>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Her bygger Maven rekursivt fra apps/app1, og bygger ingen avhengigheter som appen
                                måtte ha som ligger utenfor den arbeidskatalogen vi står i i filsystemet.
                            </p>
                        </aside>
                    </section>

                    <section>
                        <pre>
                            <code data-trim data-noescape>
apps/app1 $ mvn <mark class="fragment">-f ../.. </mark><mark class="fragment">-pl :app1 </mark><mark class="fragment">-am</mark> clean install
[INFO] Scanning for projects...
[INFO] ----------------------------------------------------
[INFO] Reactor Build Order:
[INFO]
[INFO] root                                           [pom]
[INFO] libs                                           [pom]
[INFO] lib2                                           [jar]
[INFO] lib1                                           [jar]
[INFO] apps                                           [pom]
[INFO] app1                                           [jar]
[INFO]
                            </code>
                        </pre>

						<aside class="notes">
                            <h6>A</h6>
                            <p>
                                Hvis vi holder oss i samme arbeidskatalog og ønsker å få bygd også felleskoden som app1 bruker,
                                så må vi til med noen ekstra opsjoner:
                            </p>
                            <ul>
                                <li>-f: --file (angi filsti til rot-pom, kreves for at Maven skal ta utgangspunktet i rotkatalogen og finne alle moduler i prosjektet)</li>
                                <li>-pl: --projects (prosjektlisten, hvilke moduler eller applikasjoner skal Maven bygge)</li>
                                <li>-am: --also-make (instruerer Maven til å også bygge alle avhengighetene til modulene angitt i prosjektlisten)</li>
                            </ul>
						</aside>
                    </section>

					<section>
						<h1>Mavenutfordringer med GAV-koordinater</h1>
						<ul>
                            <li>groupId<span class="fragment fade-in"> - bør utledes fra katalogstruktur</span></li>
                            <li>version<span class="fragment fade-in"> - bør utledes fra versjonskontroll</span></li>
                            <!-- TODO: ær detta nåt vi bør ta upp?		<li>Trenger nyere version av Maven for å unngå minnelekasje og få CI-vennlig "revisions"</li> -->
						</ul>

						<aside class="notes">
                            <h6>A</h6>
                            <p>
                                Maven bruker jo GroupId, ArtifactId og Version som sine koordinater for å separere moduler.
                                I en monoreposetting er det ikke alt som er like interessant, og vi skal se nærmere på to av de:
                            </p>
                            <ul>
                                <li>groupId</li>
								<li>bruk av project.version for å referere til monorepo-interna avhengigheter</li>
							</ul>

                            <p>Sammenlignet med Bazel:</p>
                            <ul>
                                <li>Mangler grupperingsbegrep à la maven groupId. Gruppering på disk er identisk med katalogstrukturen</li>
                                <li>Mangler versionsbegrep. Brukar filstrukturen på disk som versjonshandteres av VCS</li>
                            </ul>
						</aside>
					</section>

                    <section>
                        <h1>filsti == groupId</h1>
                        <p><span><code>libs/lib1</code> &rArr;</span> <code class="fragment fade-in">no.monorepo.libs.lib1</code></p>
                        <p><span class="fragment fade-in"><code>apps/app2</code> &rArr;</span> <code class="fragment fade-in">no.monorepo.apps.app2</code></p>

                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                                Maven's namespace før moduler ær baserat på groupId-begreppet. I ett monorepo ær name space
                                ivaratatt av filtrædet, och groupId-begreppet i Maven ær i princip smør på flæsk.
                                Nær man brukar Maven før monorepo kan man vurdera att sætta groupId identisk till filsti.
                            </p>
                        </aside>
                    </section>

					<section>
                        <h1>Versjonering i Maven</h1>
                        <pre>
                            <code data-trim data-noescape>
&lt;project&gt;
  &lt;groupId&gt;no.monorepo.libs&lt;/groupId&gt;
  &lt;artifactId&gt;lib1&lt;/artifactId&gt;
  &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
        					</code>
                        </pre>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Maven brukar <strong>SNAPSHOT</strong>-versjoner som tolkes som det "siste" deploy'ede binærartifakten.<br/>
                                Dette passer dårlig med monorepo-tankegangen om at <strong>versjonskontrollsystemet skal stå for versjonering</strong>, og at det er <strong>ingen avhengigheter til binære artifakter</strong>.<br/>
                                Det hadde vært mer naturlig <strong>om Maven brukte aktuell Git-revisjon</strong> som versjon, men det fungerer ikke så bra når versjonsnummeret er <strong>lagret i pom.xml</strong>-filene.<br/>
                            </p>
                        </aside>
                    </section>

                    <section>
                        <h3>CI-vennlig versjonering</h3>
                        <pre>
                            <code data-trim data-noescape>
&lt;project&gt;
  &lt;groupId&gt;no.monorepo.libs&lt;/groupId&gt;
  &lt;artifactId&gt;lib1&lt;/artifactId&gt;
  &lt;version&gt;${revision}&lt;/version&gt;

  &lt;properties&gt;
    &lt;revision&gt;1.0-SNAPSHOT&lt;/revision&gt;
  &lt;/properties&gt;
                            </code>
                        </pre>

						<pre class="fragment fade-up">
                            <code data-trim data-noescape>
$ mvn -Drevision=$(git rev-parse HEAD) clean install
						    </code>
                        </pre>

						<aside class="notes">
                            <h6>J</h6>
							<p>
                                Maven har på senare tid fått stød før så kallade  <a href="https://maven.apache.org/maven-ci-friendly.html">ci-friendly</a> versioner.
                                Det innebær att man kan parametriera version med en property som man kan sætta från kommandolinjen. Vi sætter det till git commit.
                                Tidigare har vi i många sammanhang mutera pom-filer med mvn versions:set, det slipper vi nu!
							</p>
						</aside>
                    </section>

					<section>
						<h1>Flate pom-filer</h1>
						<aside class="notes">
                            <h6>A</h6>
							<p>
                                For å unngå at pom-filer med <strong>$revision</strong>-innslag som ikke er "konkretisert" blir installert på f.eks. Nexus,
                                kan man bruke Maven <a href="https://www.mojohaus.org/flatten-maven-plugin/"><strong>flatten-pluginen</strong></a>.<br/>
                                Denna <strong>resolver revisjonsnummer, fjerner bygg- og utviklingsspesifikke detaljer som test-avhengigheter</strong> og produserer en pom-fil som er tilrettelagt for publisering til tredjepart, og som kan brukes i fremtidige bygg uten problemer.
                                I eksemplet vi har lagt ut på Github kan dere se hvordan det fungerer i praksis.
                            </p>
						</aside>
					</section>

					<section>
                        <pre>
                            <code data-trim data-noescape>
&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;no.monorepo.libs.lib1&lt;/groupId&gt;
    &lt;artifactId&gt;lib1&lt;/artifactId&gt;
    &lt;version&gt;${project.version}&lt;/version&gt;
  &lt;/dependency&gt;
						    </code>
                        </pre>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                I monorepoet er <strong>alle Maven-artifakter på samme versjon, dvs. Git HEAD</strong>.
                                Da er det naturlig å brukte project.version-propertyen for å referere til avhengigheter inne i monorepoet.
                            </p>
                        </aside>
					</section>

					<section>
						<h1>CODEOWNERS</h1>
						<pre class="fragment fade-up">
                            <code data-trim data-noescape>
# Default owner
/ @nordstrand

# Code owner for the applications
/apps/app1/   @nordstrand
/apps/app2/   @agjendem
						    </code>
                        </pre>

						<img src="img/codereview-in-github.png" alt="eksempel på hvordan github viser codereviewers via codeowners-fil" class="fragment fade-in"/>

						<aside class="notes">
                            <h6>A</h6>
							<p>
                                En av de store fordelene med <strong>multirepo</strong> er at det er <strong>lett for teamene å være autonome</strong> og på egenhånd sette opp og administrere rutiner rundt tilgang til kildekode og "peer reviews".<br/>
                                I et <strong>monorepo</strong> som deles på tvers av mange team må dette <strong>sentraliseres</strong> på tvers av teamene i større utstrekning.<br/>
                                Et vanlig oppsett er å åpne for <strong>lesetilgang</strong> til alle, men kreve <strong>godkjent "pull request"</strong> for å få lov til å merge ned på trunk.<br/>
                            </p>

							<p>
                                En <strong>CODEOWNERS-fil</strong> i monorepoet definerer hvilke team/teammedlemmer som eier koden under ulike filstier.<br/>
                                Dette kan brukes til å f.eks. automatisk legga inn eiere som reviewers på pull requester som treffer deres respektive kode.<br/>
                            </p>

							<p>
                                CODEOWNERS-filformatet er <a href="https://help.github.com/articles/about-codeowners/"><strong>standardisert</strong></a>
                                og støttes av Github hvis man er betalende bruker, samt Gitlab og Bitbucket Server med plugin.
							</p>

							<p>
                                I dette eksempelet blir Jonas automatisk lagt til som reviewer med et spesielt nøkkelhullikon på alle pull requests som treffer hans app - app1.
                            </p>
						</aside>
					</section>

                    <section>
                        <h1>Jenkins(file)</h1>
                        <pre class="fragment fade-up">
                            <code data-trim data-noescape>
$ git diff --name-only origin/master...HEAD
apps/app2/src/main/java/no/monorepo/app2/App2.java
apps/app2/README.md
                            </code>
                        </pre>

                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                                I ett monorepo vill man ha møjligt att køra olika byggpipelines beroende på vilka filer som har ændrat sig.
                                Vi har valt att lægga upp egna Jenkinsfile's før varje app i monorepot så att teamen har møjlighet
                                att f.eks. sætta upp sina testmiljøer som man ønskar.
                            </p>
                            <p>
                                Detta har i utgångspunkt inte Jenkins stød før, och det finns inte heller læmpliga plugins att tillgå.
                                Vi har løst detta med en root Jenkinsfile som hjælp av git diff finner fram till exakt vilka filer som har ændrats
                                i en PR jæmført mot master.
                            </p>
                        </aside>
                    </section>

                    <section>
                        <h1>Jenkins(file)</h1>
                        <img alt="Logo for Jenkins" src="img/Jenkinsfile.png" />

                        <aside class="notes">
                            <h6>J</h6>
                            Vår root-jenkinsfile finner vilka Jenkinsfile(s) som ær berørda av diffen och delegerar till den mest specifika.

                            Gør man ændring på felleskode så berørs i regel flera Jenkinsfile och lastar då en default pipeline som bygger hela
                            monorepo't.
                        </aside>
                    </section>

                    <section>
                        <h1>partial-build-plugin</h1>
                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                                Att bygg <strong>hela</strong> monorepo't från maven clean blir en længre och længre process ju større repo't blir.
                                Andra byggsystem (Bazel) har stød før inkrementell bygging, dær bara den kod som har ændrats och dess avhængigheter blir byggt. Vi tar tagit i bruk
                                <a href="https://github.com/lesfurets/partial-build-plugin">partial-build-plugin</a> en plugin som hackar sig in i maven
                                byggning och prøvar att bara bygga moduler som har en diff mot trunk, lite likt upplægget kring val av Jenkinsfile.
                                Dessværre ær pluginen insomnad på Github, men den har fungerat fint før oss så långt.
                            </p>
                        </aside>
                    </section>

                    <section>
                        <h2>Git sparse checkouts</h2>
                        <pre class="fragment fade-up">
                            <code data-trim data-noescape>
.git/info/sparse-checkout
/*
!/apps/*/*
/apps/app1/*
                            </code>
                        </pre>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Hvis <strong>kodebasen</strong> blir så stor at det er <strong>upraktisk å laste ned</strong> alt, eller man faktisk bare <strong>jobber med en konkret applikasjon</strong> uten behov for å endre felleskode så finnes det utveier.<br/>
                                Med <strong>"sparse checkouts"</strong> kan man instruere Git til å sjekke ut en delmengde av arbeidstreet.<br/>
                                I eksemelet her så sier vi at vi i utgangspunktet vil ha alle filer, men ikke alle applikasjonene, før vi igjen sier at vi vil ha app1 som er den vi jobber på.<br/>
                                Resultatet blir da at vi får det vi trenger av felleskode samt app1.<br/>
                                Det kan være gunstig med tanke på indekseringstid i f.eks. IntelliJ.<br/>
                                Ved å bruke sparse checkouts på denne måten får man i praksis en <strong>utvikleropplevelse som er temmelig lik den man har med multirepo</strong>, foruten at felleskoden er tilgjengelig.<br/>
                                Hvis man endrer på felleskoden bør man jo helst ha all koden tilgjengelig.<br/>
                                Eventuelt så vil forhåpentligvis byggserveren og tester plukke opp eventuelle feil og mangler.<br/>
                            </p>
                            <p>
                                Nå skurrer kanskje dette litt for mange av dere, <strong>Maven vil jo ikke like at halve kodebasen er borte</strong>?<br/>
                                I utgangspunktet <strong>støtter ikke Maven sparse checkouts</strong>, siden modul-lista i apps f.eks. vil referere til applikasjoner vi ikke har koden til.<br/>
                                Maven ønsker jo å bygge en komplett modell av alle modulene, basert på pom.xml før den gjør noe som helst, og vil selvfølgelig protestere.<br/>
                            </p>
                        </aside>
                    </section>

                    <section>
                        <pre>
                            <code data-trim data-noescape>
&lt;profile&gt;
  &lt;id&gt;app2&lt;/id&gt;
  &lt;activation&gt;
    &lt;file&gt;
      &lt;exists&gt;app2/pom.xml&lt;/exists&gt;
    &lt;/file&gt;
  &lt;/activation&gt;
  &lt;modules&gt;
    &lt;module&gt;app2&lt;/module&gt;
  &lt;/modules&gt;
&lt;/profile&gt;
                            </code>
                        </pre>

                        <aside class="notes">
                            <h6>A</h6>
							<p>
                                Ved å bruke <strong>Maven-profiler</strong> litt kreativt kan vi komme oss rundt dette, og bygge opp modules-lista basert på profiler.<br/>
                                Disse profilene igjen <strong>trigges av om pom.xml-fila til appen faktisk finnes</strong>.<br/>
                                På den måten får vi en <strong>dynamisk liste av applikasjonsmoduler</strong> slik Maven ser det, og det fungerer "greit nok".<br/>
							</p>
                        </aside>
                    </section>
				</section>

				<section>
					<section>
						<h1>Rosa sky eller tornekratt?</h1>
                        <ul>
                            <li>Stort repo</li>
                            <li>Lange byggtider</li>
                            <li>The race to merge</li>
                            <li>Monolit 2.0</li>
                            <li>Verktøy</li>
                       </ul>
						<aside class="notes">
                            <h6>J</h6>
							<p>
								(7 min)
								Hvilke nye utfordringer får vi nå?
								* Umodne verktøy (Maven vs Bazel, BitBucket / GitHub vs Gerrit)
								* Tvinges til mer kortlevde brancher
								* Skalering
							</p>
						</aside>
					</section>

                    <section>
                        <h1>Stort repo</h1>
                        <ul>
                            <li>.git/
                                <ul class="fragment fade-in">
                                    <li>VFS for Git</li>
                                </ul>
                            </li>
                            <li>work tree
                                <ul>
                                    <li class="fragment fade-in">Sparse Checkouts</li>
                                    <li class="fragment fade-in">Large File Storage</li>
                                </ul>
                            </li>
                        </ul>

                        <aside class="notes">
                            <h6>A</h6>
                            Over tid vokser gjerne kodebasen. Per i dag så regner vi ikke med at <i>vi</i> møter på de største problemene - kanskje med unntak av prosjekter hvor vi versjonerer <strong>store maskinlæringsmodeller</strong> og andre binære datafiler.
                            Avhengig av hva som er årsaken, er det flere måter å angripe problemet på:<br/>
                            <ul>
                                <li>Vente og håpe verktøyene blir bedre av seg selv</li>
                                <li>Hvis det er metadata/historikk i .git/-katalogen kan kanskje virtuelle filsystem a'la Microsofts <strong>VFS for Git</strong> være løsningen. Foreløpig best støtte på Windows, men Mac støttes og Linux ser ut til å være under arbeid.</li>
                                <li>Hvis det er working-treet som er problemer er kanskje <strong>sparse checkouts</strong> som nevnt over en del av løsningen</li>
                                <li>også kan det kanskje være lurt å så på om <strong>Git Large File Storage</strong> kan være et alternativ for å unngå å ha store binærfiler som del av selve repositoriet. <strong>Arbeidsflyten i Git forblir uendret</strong> når de filene som skal lagres med LFS er definert, så det kan være et godt alternativ. I praksis så lagres det en fil med en peker til hvor fila kan finnes. Den lagres på en egen LFS-server knyttet til repositoriet ditt. Både Github og BitBucket støtter LFS.</li>
                            </ul>
                        </aside>
                    </section>

                    <section>
                        <ul>
                            <li>Google's monorepo: 2 milliarder filer, 2018</li>
                            <li>Microsoft Windowsrepoet: 3.5 millioner filer / 4000 brukere (som GVFS)</li>
                            <li>Linuxkernelen: 65.000 filer<li>
                            <li class="fragment fade-in">Summan av SpareBank 1s nettbankmultirepoer: 40.000 filer</li>
                            <li class="fragment fade-in">SpareBank 1s nettbankmonorepo: 1.500 filer</li>
                        </ul>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Vi prøvde å finne noen tall på hva de store har stappet inn i sine Git repository.<br/>
                                Som vi ser her, så er vi jo bare smågutter, så vi er <strong>ikke spesielt bekymret for skaleringen</strong> i så måte.<br/>
                                <strong>Nettbanken</strong> vår består av rundt 40.000 filer, kanskje.<br/>
                                Det er <strong>vanskelig å få oversikt</strong> siden det er oppdelt i så mange repository.<br/>
                                I monorepoet er det trivielt å få oversikten, og foreløpig er det veldig tidlig i migreringen.<br/>
                                Vi har per nå i overkant av <strong>20</strong> små, tilstandsløse applikasjoner der, fordelt på cirka <strong>1500 filer</strong>.<br/>
                            </p>

                            <hr />
                            <a href="https://git-lfs.github.com/">Git Large file storage</a><br/>
                            <a href="https://github.com/Microsoft/VFSForGit/issues/126">VFS for Git on Linux</a><br/>
                            <a href="https://github.com/github/libprojfs">VFS for Git on Linux</a><br/>
                        </aside>
                    </section>

                    <section>
                        <h1>Lange byggtider</h1>
                        <ul>
                            <li>Ikke bygg alt alltid</li>
                            <li>Ikke bygg fra "clean" alltid <span class="fragment fade-in">(vurder alternativ til Maven)</span></li>
                            <li class="fragment fade-in">Bazel har støtte for <i>build cache</i> og <i>build workers</i></li>
                        </ul>

                        <aside class="notes">
                            <h6>J</h6>
                            Bazel har stød før 100% pålitligta inkrementella bygg vilket troligen hjælper till med CI rætt bra.
                        </aside>
                    </section>

					<section data-background="img/race.jpg" data-background-size="contain">
						<h1 style="margin-top: -200px; text-shadow: 0 0 4px #FFFFFF; background: rgba(255,255,255,0.6)">The race to merge</h1>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                I et monorepo ønsker man naturligvis at master-branchen <strong>alltid</strong> skal bygge grønt.<br/>
                                For å sikre dette kan man ikke tillate å merge pull requester som ikke er <strong>basert på siste versjon av master</strong>.<br/>
                                Altså <strong>må</strong> man <strong>rebase</strong> inn master i pull requesten før den kan merges.<br/>
                            </p>
                            <p>
                                Det store problemet med dette, er at etter at man har <strong>rebaset pull requesten</strong> sin, og alle testene har kjørt igjen,
                                så har noen andre rukket å få merget sin pull request før deg.. og da er det bare å starte på nytt.
                            </p>
                            <p>
                                Vi har fremdeles <strong>ikke "løst" dette problemet</strong>, men det begynner å nærme seg at vi må ta en mer omfattende kikk på denne biten.<br/>
                                <strong>Jo flere utviklere og applikasjoner vi ruller på, jo verre blir det</strong>.<br/>
                                Antakelig er løsningen en eller annen form for <strong>automatisering</strong> hvor man markerer at "denne pull requesten ønsker jeg å merge",
                                også blir den <strong>lagt i kø</strong> og håndtert automatisk så lenge alle testene fremdeles kjører grønt.
                            </p>

                            <hr />
                            <a href="https://docs.microsoft.com/en-us/azure/devops/learn/git/race-to-push">The race to push</a><br/>
							Bild av <a href="https://pixabay.com/sv/users/skeeze-272447/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=558089">skeeze</a>
                            från <a href="https://pixabay.com/sv/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=558089">Pixabay</a>
                        </aside>
                    </section>

                    <section>
                        <h1>Monolit 2.0</h1>

                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                            I ett monorepo ær det lættare æn någonsin att dela kode och inføra nya avhængigheter - nu slipper man faktiskt krullet med att finna
                            fram till vilken version man ønskar. Baksidan av myntet ær det ær rætt lætt att vara odisciplinerad och lægga inte avhængigheter på lite væl
                            mycket felleskode, och, om man inte pasar sig, så har vi kanske snart en ny tætt kopplad monolit.
                            </p>
                            <p>
                            Detta må vi undgå. Vi har ænnu inte kommit till den punkten dær detta kan bli ett problem, men med større skala så ær vi nyfikna
                            på att titta på kodekvalitetsverktyg som <a href="https://www.archunit.org/">Archunit</a>. Archunit låter dig skriva junit-enhetstester
                            som på klassnivå verfieriar att man f.eks. inte har avhængigheter mellan appar i ett monorepo.
                            </p>
                        </aside>
                    </section>

                    <section>
                        <h2>Overmodne verktøy</h2>

                        <div style="display: flex">
							<span>
                                <img  src="img/maven.png" alt="Maven logo" />
							</span>
							<span>
                                <img  src="img/jenkins.png" class="fragment" alt="Jenkins logo" />
							</span>
                        </div>

                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Maven begynner jo å dra på årene, førsta release av <a href="https://maven.apache.org/docs/history.html"><strong>Maven ble sluppet 30. mars 2002</strong></a>.<br/>
                                I 2005 kom Maven 2.0, i 2010 kom Maven 3.0, og på de årene har mange andre verktøy kommet og godt, og mye har skjedd.<br/>
                            </p>
                            <p>
                                Mange av <strong>de tingene som knirker mest</strong> nå i Maven-monoreposammenheng har vi allerede vært inne på:<br/>
                            </p>
                            <ul>
                                <li>Ikke polyglot - <strong>Javasentrisk</strong></li>
                                <li><strong>Sparse checkout må hackes til</strong> siden Mavens repomodell bygges opp av pom.xml filer - ikke hva som finnes på disk</li>
                                <li>Maven trenger <strong>eksplisitt referanse til roten</strong> av repositoryet. Bazel finner den fint selv.</li>
                                <li><strong>Mangler inkrementella bygg</strong> - man bygger i hovedsak alltid fra clean tilstand</li>
                                <li>Maven brukar <strong>groupId og versjons-begrep</strong> for moduler som i et monorepo <strong>heller utledes</strong> fra filkatalogstrukturen i Git</li>
                            </ul>
                            <p>
                                Jenkins er en annen gammel traver som først så dagens lys under navnet Hudson tilbake i 2008.<br/>
                                Mange år og mange plugins senere, så mangler Jekins fremdeles støtte for monorepo i form av selektiv bygging basert på diff.<br/>
                                CodeFresh har <a href="https://codefresh.io/continuous-integration/using-codefresh-with-mono-repos/">støtte for monorepo</a>!<br/>
                            </p>
                        </aside>
                    </section>

                    <section>
                        <h1>Umodne verktøy</h1>
                        <ul>
                            <li>Bazel er i beta og har middels verktøystøtte</li>
                            <li>CI - mangler ferdige løsninger for å bygge deler av monorepo</li>
                            <li>Bitbucket/Github mangler ordentlig støtte for store monorepo - CODEOWNERS er et plaster</li>
                        </ul>
                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                            </p>
                        </aside>
                    </section>

                    <section>
                        <h1>... men</h1>
                        <ul>
                            <li>.. dette er jo ikke et ekte monorepo!</li>
                            <li><a href="https://medium.com/@mattklein123/monorepos-please-dont-e9a279be011b">.. monorepo er latterlig, ikke gjør det!</a></li>
                            <li>.. dere støtter jo bare ett språk!</li>
                            <li>.. dere har jo bare noen få applikasjoner i repoet!</li>
                            <li>.. definisjonen er jo at <strong>alt</strong> av kode skal bo i ett repo!</li>
                            <li>.. monorepo skalerer ikke</li>
                            <li>.. monorepo er en &lt;flopp|hype&gt;</li>
                            <li>.. andre innspill?</li>
                        </ul>
                        <aside class="notes">
                            <h6>A</h6>
                            <p>
                                Det er fordeler og ulemper med alt. Vi har nå prøvd multirepo i ganske mange år, og
                                håndterer forsåvidt det "greit nok" - men det er ikke gøy med 100+ repository heller.

                                Nå hadde vi muligheten til å se på om monorepo kunne løse noen av våre utfordringer,
                                og vi har tid og lyst til å se om dette kan være noe for oss i større eller mindre skala.

                                Mange av ankepunktene mot monorepo gjelder store organisasjoner med enorme mengder kode.
                                Vi har mange utviklere, vi har mye kode, på mange språk, men vi er på ingen måte enorme.
                                Det finnes kanskje en middelvei her?

                                Vi tror at ved å begynne i det små og ta stegene gradvis så bør vi greie å komme opp med en god løsning på utfordringene,
                                og kunne løse de større over tid når de nærmer seg et problem. Foreløpig er vel kanskje
                                hybrid-repo et bedre navn på det vi gjør, og vi tenker at det er helt greit å ta skrittene
                                gradvis. Det er ikke gitt at det er fornuftig for oss å blande alt i en stor haug, men
                                å samle det som hører sammen virker forlokkende, ihvertfall.

                                Hvis dette ikke er en flopp, så har det en tendens til å dukke opp løsninger på utfordringene
                                i form av nye verktøy og bedre tredjepartsstøtte, se bare på Bazel.

                                Vi ser ingen grunn til å ikke utforske mulighetene, og i verste fall så er det ingen big deal å splitte
                                opp til flere repository igjen, den biten kan vi. Også er det jo også slik at vi har
                                brukt, og bruker den dag i dag mye tid på tooling for multirepo også.

                                Igjen; alt gjør vondt, spørsmålet er bare hvor du foretrekker å ha smerten.
                            </p>
                        </aside>
                    </section>
				</section>

				<section>
                    <section>
                        <h1>Effekter</h1>

                        <aside class="notes">
                            <h6>J</h6>
                            <p>
							Jobbing i ett monorepo ær på många sætt rætt radikalt annorlunda æn hur vi jobbar med multirepo idag.
							</p>
							<p>
							Att vi børjade med monorepo var inte bara før att monorepo ær <i>the next shiny thing</i> vi trodde också att
							det faktiskt skulle ha en del utslagsgivande positiva effekter. Vi har nu tillræckligt med praktiska erfarenhet før att kunna dela lite kring
							vilka effekter vi har upplevt.
                            </p>
							<hr />
							<p>
                            (7 min)
                            Med monorepo; hva blir mer viktig, og hva blir mindre viktig?
                            Hvordan påvirker monorepo samarbeidet i organisasjonen?
                            Positive bi-effekter av monorepo.
                            </p>
                        </aside>
                    </section>

					<section>
                        <h1>Versjonering</h1>
                        <span>
                            <span class="fragment versionconcept">$ mvn version set</span>
                            <span class="fragment versionconcept">$ mvn release:begin</span>
                            <span class="fragment versionconcept">&lt;version&gt;</span>
                            <span class="fragment versionconcept">-SNAPSHOT</span>
                            <span class="fragment versionconcept">&lt;dependencyManagement&gt;</span>
                        </span>
						<aside class="notes">
							<h6>A</h6>
							<p>
                                Tidigare versionerade vi i git _och_ maven. I monorepo versionerar vi bara i git.

                                Konceptuellt lættare att førhålla sig till git (en viss SHA1 tillsvarar att
                                allt ska vara i sync), æn att førhålla sig till &lt;dependencyManagement&gt;,
                                bom'ar, snapshots, dependency version convergence (risiko før detta utgår helt på
                                egen felleskode i monorepot, 3e part kan fortfarande vara ett issue om dessa ikke
                                också ligger i monorepot), maven sin release-plugin, NPM:s semver, pinning, lock-filer,
                                etc. etc. allt annat som folk uppfunnit genom historiens før før att
                                førsøka gøra versionering av felleskode i artefaktregistries levlig.
							</p>
							<p>
							Mindre behov før komplex tooling før att hålla appar uppdaterade med nya versioner
							av felleskode.
							</p>
						</aside>
					</section>

                    <section>
                        <h2>Jobbing med felleskode</h2>
						<p class="ffe-lead-paragraph">Hvis du ikke har et monorepo, integrerer du ikke kontinuerlig - i beste fall hyppig!</p>
                        <aside class="notes">
                            <h6>J</h6>
                            <p>
								Att jobba med felleskode i ett monorepo ær helt annorlunda, och bættre, æn i multirepo. Ønskar du
								se alla konsumenter av en API-funktion? Det ær bara ett IDE-kommando bort.
								Nyfiken på om en felleskodeændring knæcker en konsument? Det ær enkelt (i alla fall i Bazel)
								att køra alla konsumenteras tester. Ær det något som knæcker så ær det møjligt att fixa
								det i samma PR som felleskodeændringen! Man kan laga <i>atomiska refaktoreringar</i> som
								ær lætta rulla bak, som resulterar i holistiska PR:s dær man ser hela bilden/diffen!
								Sammantaget sænker monorepo trøskeln, som annars kan vara rætt høg, før att folk vågar refaktorer/bidra till felleskode.
							</p>
							<p>
								Det ær inte længre møjligt att vælja att inte ta in en ny version av felleskode. Felleskodeændringar
								integreras kontinuerligt i apparna: betydligt mer kontinuerligt æn vad som brukar vara fallet i
								multirepo. Sækerhetsuppdateringar och kritiska bugfixar får en rask T2M.
							</p>
							<p>
                               Tidigare kunde man ændra felleskode utan att att ta ansvara før att integrera
                               ændringen i konsumenterna. Med monorepo blir man mer ansvarligt før konsumenterna,
                               det blir också praktiskt møjligt att gøra det.
                            </p>
                        </aside>
                    </section>

                    <section data-background="img/2nd-order-effects.jpg" data-background-size="contain">
                        <h1 style="color:white">Second order effects</h1>
                        <br/><br/><br /><br/>
                        <h3 style="color:white">i SpareBank 1 Utveckling</h3>
                        <aside class="notes">
                            <h6>A</h6>
                            <p>Vår nettbank har historiskt varit uppdelat i två olika "marknader": privat och bedrift.
                            Dessa har betjænats av olika team och det har uppstått många tillfæller dær samma typ av
                            app lagats två gånger, en gång i en privat-smak och gång i en bedrift-smak.</p>

                            <p>Monorepo't læægger upp till bættre genomsiktligt och samarbetsmøjligheter på tværs av
                            team och vi ser nu tillfællen av appar som kan upptræda som i både privat och bedriftsammanhang
                            från samma kodebas</p>
                            <hr />
                            Biljardbild: https://pixabay.com/photos/billiards-pool-play-game-sport-1967938/
                        </aside>
                    </section>

                    <section data-background="img/survey.jpg" data-background-size="contain">
                        <h1>Googles erfaringar</h1>
                        <br/><br/><br/><br/><br/><br/><br/>
                        <p class="ffe-small-text" style="color:black; background-color: rgba(255, 255, 255, 0.2);">Advantages and Disadvantages of a Monolithic Repository:
                        A case study at Google<br/>
                        Ciera Jaspan, Matthew Jorde, Andrea Knight, Caitlin Sadowski, Edward K. Smith, Collin Winter-Google;
                        Emerson Murphy-Hill NC State University
                        </p>
                        <aside class="notes">
                            <h6>J</h6>
                            <p>
                            Någon som har <strong>en del</strong> monorepoerfarenhet ær Google.
							Google har ett gigantisk monorepo med faktiskt <strong>decennier</strong> med historik. Repo't anvænds av øver 20.000 utvecklare.
                            Google ær intresserade av vad deras erfarenheter och gick i 2018 vetenskapligt till verks. Det genomførde
							en større enkætundersøkelse samtidigt som det samlades in loggdata om hur repo't anvændes.
                            </p>

                            <p>
                            Det visade sig att utvecklarna starkt preferade ett jobba i monorepo't nær detta sattes
                            upp mot tidigare erfarenhet av jobb i en multirepo-miljø. (så det var kanske inte helt bortkastat att gå på den hær talken)
							Det kan naturligtvis ifrågasættas i vilken grad det resultatet berodde på den inneboende styrkan i monorepotankegången och
                            i vilken grad resultatet kan vara påverkat av kvalitèn på Googles utvecklingsverktyg (versionshantering,
                            code review, code browsing, etc.) versus mot dær man hade jobbat med multirepo tidigare.
                            </p>

                            <p>
                            En kanske lite ovæntad finding var att den aspekt av monorepo't som utvecklarna satte mest pris på <strong>inte</strong>
                            var enkel versionering, atomiska refaktoreringar eller något annat av det vi næmnt tidigare.<br/>
                            Nej, det var møjligheten att lætt kunna søka i och læsa all kællkod før att f.eks. finna relevanta kodeexempler som kom ut på topp.
                            </p>

                            <p>
                            Undersøkelse blev till ett <a href="https://people.engr.ncsu.edu/ermurph3/papers/seip18.pdf">intressant paper</a> som varmt rekommenderas.
                            </p>
                            <hr/>
                            Bilde: https://pixabay.com/photos/survey-opinion-research-voting-fill-1594962/
                        </aside>
                    </section>

                    <section data-background="img/success.jpg" data-background-size="contain">
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <br/>
                        <h2 style="text-shadow: 0 0 4px #FFFFFF; background: rgba(255, 255, 255, 0.4)">Du får det till med Maven, Jenkins og Git!</h2>
                        <h2 class="fragment fade-in" style="text-shadow: 0 0 4px #FFFFFF; background: rgba(255, 255, 255, 0.4)">...men på sikt ryker nok Maven!</h2>
                        <aside class="notes">
                            <h6>A</h6>
                            <hr />
                            Bild av <a href="https://pixabay.com/sv/users/StartupStockPhotos-690514/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=593313">StartupStockPhotos</a> från <a href="https://pixabay.com/sv/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=593313">Pixabay</a>
                        </aside>
                    </section>
				</section>


				<section>
					<h1>Takk for oss!</h1>

					<p>
						<a href="https://github.com/SpareBank1/monorepo-sample">github.com/SpareBank1/monorepo-sample</a><br/>
						<img style="width:300px;height:300px" alt="QR-kode til https://github.com/SpareBank1/monorepo-sample" src="img/repo-url-qr.png" />
					</p>

					<h4>kortreistkode.no</h4>
					<h4>Jonas Nordstrand / Anders Gjendem</h4>

					<aside class="notes">
						<h6>En av oss:</h6>
						<p>
							Hejdå!
						</p>
					</aside>
				</section>

                <!--
                  TODO:s

                  DELIVERY

                  JONAS:
                   * Sluta "smacka"!
                -->

                <!-- TODO: ... -->
                <!--                    <section>-->
                <!--                        Restpost-->
                <!--						<aside class="notes">-->
                <!--							<h6>En av oss:</h6>-->
                <!--                            <h1>Løsninger</h1>-->
                <!--                            <ul>-->
                <!--                                <li>Bazel?</li>-->
                <!--                                <li>Archunit?</li>-->
                <!--                            </ul>-->
                <!--	                            <ul>-->
                <!--                                <li>Python i Monorepo?</li>-->
                <!--                                <li>Rydde i repo</li>-->
                <!--                            </ul>-->
                <!--						</aside>-->
                <!--					</section>-->
			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                history: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>
